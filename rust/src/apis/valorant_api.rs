/*
 * HenrikDev API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.6.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`crosshair`]
#[derive(Clone, Debug)]
pub struct CrosshairParams {
    /// Crosshair code
    pub id: Option<String>
}

/// struct for passing parameters to the method [`esports_event_v2`]
#[derive(Clone, Debug)]
pub struct EsportsEventV2Params {
    pub event_id: u32
}

/// struct for passing parameters to the method [`esports_events_v2`]
#[derive(Clone, Debug)]
pub struct EsportsEventsV2Params {
    pub region: Option<models::EsportsV2Region>,
    pub r#type: Option<models::EsportsV2EventType>,
    pub page: Option<u32>
}

/// struct for passing parameters to the method [`esports_match_v2`]
#[derive(Clone, Debug)]
pub struct EsportsMatchV2Params {
    pub match_id: u32
}

/// struct for passing parameters to the method [`esports_player_matches_v2`]
#[derive(Clone, Debug)]
pub struct EsportsPlayerMatchesV2Params {
    pub player: u32,
    pub page: Option<u32>
}

/// struct for passing parameters to the method [`esports_player_v2`]
#[derive(Clone, Debug)]
pub struct EsportsPlayerV2Params {
    pub player: u32,
    pub timespan: Option<models::EsportsV2PlayerTimespan>
}

/// struct for passing parameters to the method [`esports_schedules_v1`]
#[derive(Clone, Debug)]
pub struct EsportsSchedulesV1Params {
    pub region: Option<String>,
    pub league: Option<String>
}

/// struct for passing parameters to the method [`esports_team_matches_v2`]
#[derive(Clone, Debug)]
pub struct EsportsTeamMatchesV2Params {
    pub team_id: u32,
    pub page: Option<u32>
}

/// struct for passing parameters to the method [`esports_team_transactions_v2`]
#[derive(Clone, Debug)]
pub struct EsportsTeamTransactionsV2Params {
    pub team_id: u32
}

/// struct for passing parameters to the method [`esports_team_v2`]
#[derive(Clone, Debug)]
pub struct EsportsTeamV2Params {
    pub team_id: u32
}

/// struct for passing parameters to the method [`get_account_by_id_v1`]
#[derive(Clone, Debug)]
pub struct GetAccountByIdV1Params {
    /// Player UUID
    pub puuid: String,
    /// Bypass cache and refresh (optional)
    pub force: Option<bool>
}

/// struct for passing parameters to the method [`get_account_by_id_v2`]
#[derive(Clone, Debug)]
pub struct GetAccountByIdV2Params {
    /// Player UUID
    pub puuid: String,
    /// Bypass cache and refresh (optional)
    pub force: Option<bool>
}

/// struct for passing parameters to the method [`get_account_v1`]
#[derive(Clone, Debug)]
pub struct GetAccountV1Params {
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Bypass cache and refresh (optional)
    pub force: Option<bool>
}

/// struct for passing parameters to the method [`get_account_v2`]
#[derive(Clone, Debug)]
pub struct GetAccountV2Params {
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Bypass cache and refresh (optional)
    pub force: Option<bool>
}

/// struct for passing parameters to the method [`get_content_v1`]
#[derive(Clone, Debug)]
pub struct GetContentV1Params {
    /// Locale code (e.g., en-US, de-DE) - optional
    pub locale: Option<String>
}

/// struct for passing parameters to the method [`get_matches_v3_by_id`]
#[derive(Clone, Debug)]
pub struct GetMatchesV3ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Player UUID
    pub puuid: String,
    /// Game mode filter (optional)
    pub mode: Option<String>,
    /// Map filter (optional)
    pub map: Option<String>,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`get_matches_v3_by_name`]
#[derive(Clone, Debug)]
pub struct GetMatchesV3ByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Game mode filter (optional)
    pub mode: Option<models::MatchMode>,
    /// Map filter (optional)
    pub map: Option<String>,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`get_matches_v4_by_id`]
#[derive(Clone, Debug)]
pub struct GetMatchesV4ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Player UUID
    pub puuid: String,
    /// Game mode filter (optional)
    pub mode: Option<String>,
    /// Map filter (optional)
    pub map: Option<String>,
    /// Number of results (optional)
    pub size: Option<i32>,
    /// Start index for pagination (optional)
    pub start: Option<i32>
}

/// struct for passing parameters to the method [`get_matches_v4_by_name`]
#[derive(Clone, Debug)]
pub struct GetMatchesV4ByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Game mode filter (optional)
    pub mode: Option<String>,
    /// Map filter (optional)
    pub map: Option<String>,
    /// Number of results (optional)
    pub size: Option<i32>,
    /// Start index for pagination (optional)
    pub start: Option<i32>
}

/// struct for passing parameters to the method [`get_mmr_history_by_id`]
#[derive(Clone, Debug)]
pub struct GetMmrHistoryByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Player UUID
    pub puuid: String
}

/// struct for passing parameters to the method [`get_mmr_history_by_name`]
#[derive(Clone, Debug)]
pub struct GetMmrHistoryByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String
}

/// struct for passing parameters to the method [`get_mmr_history_v2_by_id`]
#[derive(Clone, Debug)]
pub struct GetMmrHistoryV2ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Player UUID
    pub puuid: String
}

/// struct for passing parameters to the method [`get_mmr_history_v2_by_name`]
#[derive(Clone, Debug)]
pub struct GetMmrHistoryV2ByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String
}

/// struct for passing parameters to the method [`get_mmr_v1_by_id`]
#[derive(Clone, Debug)]
pub struct GetMmrV1ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Player UUID
    pub puuid: String
}

/// struct for passing parameters to the method [`get_mmr_v1_by_name`]
#[derive(Clone, Debug)]
pub struct GetMmrV1ByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String
}

/// struct for passing parameters to the method [`get_mmr_v2_by_id`]
#[derive(Clone, Debug)]
pub struct GetMmrV2ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Player UUID
    pub puuid: String
}

/// struct for passing parameters to the method [`get_mmr_v2_by_name`]
#[derive(Clone, Debug)]
pub struct GetMmrV2ByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String
}

/// struct for passing parameters to the method [`get_mmr_v3_by_id`]
#[derive(Clone, Debug)]
pub struct GetMmrV3ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Player UUID
    pub puuid: String
}

/// struct for passing parameters to the method [`get_mmr_v3_by_name`]
#[derive(Clone, Debug)]
pub struct GetMmrV3ByNameParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String
}

/// struct for passing parameters to the method [`leaderboard_v1`]
#[derive(Clone, Debug)]
pub struct LeaderboardV1Params {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Season ID (optional)
    pub season: Option<String>,
    /// Player name to search for (optional)
    pub name: Option<String>,
    /// Player tag to search for (optional)
    pub tag: Option<String>
}

/// struct for passing parameters to the method [`leaderboard_v2`]
#[derive(Clone, Debug)]
pub struct LeaderboardV2Params {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Season ID (optional)
    pub season: Option<String>,
    /// Player name to search for (optional)
    pub name: Option<String>,
    /// Player tag to search for (optional)
    pub tag: Option<String>,
    /// Player UUID to search for (optional)
    pub puuid: Option<String>
}

/// struct for passing parameters to the method [`leaderboard_v3`]
#[derive(Clone, Debug)]
pub struct LeaderboardV3Params {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Season ID (optional)
    pub season: Option<String>,
    /// Number of results per page (optional)
    pub size: Option<i32>,
    /// Page number (optional)
    pub page: Option<i32>,
    /// Player name to search for (optional)
    pub name: Option<String>,
    /// Player tag to search for (optional)
    pub tag: Option<String>
}

/// struct for passing parameters to the method [`match_v2`]
#[derive(Clone, Debug)]
pub struct MatchV2Params {
    /// Match UUID
    pub match_id: String
}

/// struct for passing parameters to the method [`match_v4`]
#[derive(Clone, Debug)]
pub struct MatchV4Params {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Match UUID
    pub match_id: String
}

/// struct for passing parameters to the method [`premier_by_id`]
#[derive(Clone, Debug)]
pub struct PremierByIdParams {
    /// Team UUID
    pub id: String
}

/// struct for passing parameters to the method [`premier_by_id_history`]
#[derive(Clone, Debug)]
pub struct PremierByIdHistoryParams {
    /// Team UUID
    pub id: String
}

/// struct for passing parameters to the method [`premier_by_name`]
#[derive(Clone, Debug)]
pub struct PremierByNameParams {
    /// Team name
    pub name: String,
    /// Team tag
    pub tag: String
}

/// struct for passing parameters to the method [`premier_by_name_history`]
#[derive(Clone, Debug)]
pub struct PremierByNameHistoryParams {
    /// Team name
    pub name: String,
    /// Team tag
    pub tag: String
}

/// struct for passing parameters to the method [`premier_leaderboard`]
#[derive(Clone, Debug)]
pub struct PremierLeaderboardParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Conference filter (optional)
    pub conference: Option<String>,
    /// Division filter (optional)
    pub division: Option<String>
}

/// struct for passing parameters to the method [`premier_search`]
#[derive(Clone, Debug)]
pub struct PremierSearchParams {
    /// Team name to search for (optional)
    pub name: Option<String>,
    /// Team tag to search for (optional)
    pub tag: Option<String>,
    /// Team UUID to search for (optional)
    pub id: Option<String>
}

/// struct for passing parameters to the method [`queue_status`]
#[derive(Clone, Debug)]
pub struct QueueStatusParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String
}

/// struct for passing parameters to the method [`raw`]
#[derive(Clone, Debug)]
pub struct RawParams {
    pub raw_v1_payload: models::RawV1Payload
}

/// struct for passing parameters to the method [`status`]
#[derive(Clone, Debug)]
pub struct StatusParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String
}

/// struct for passing parameters to the method [`store_featured`]
#[derive(Clone, Debug)]
pub struct StoreFeaturedParams {
    /// API version (v1, v2)
    pub version: String
}

/// struct for passing parameters to the method [`store_offers`]
#[derive(Clone, Debug)]
pub struct StoreOffersParams {
    /// API version (v1, v2)
    pub version: String
}

/// struct for passing parameters to the method [`stored_matches`]
#[derive(Clone, Debug)]
pub struct StoredMatchesParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Game mode filter (optional)
    pub mode: Option<String>,
    /// Map filter (optional)
    pub map: Option<String>,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`stored_matches_by_id`]
#[derive(Clone, Debug)]
pub struct StoredMatchesByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Player UUID
    pub puuid: String,
    /// Game mode filter (optional)
    pub mode: Option<String>,
    /// Map filter (optional)
    pub map: Option<String>,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`stored_mmr_history`]
#[derive(Clone, Debug)]
pub struct StoredMmrHistoryParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`stored_mmr_history_by_id`]
#[derive(Clone, Debug)]
pub struct StoredMmrHistoryByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Player UUID
    pub puuid: String,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`stored_mmr_history_v2`]
#[derive(Clone, Debug)]
pub struct StoredMmrHistoryV2Params {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Riot ID name
    pub name: String,
    /// Riot ID tag
    pub tag: String,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`stored_mmr_history_v2_by_id`]
#[derive(Clone, Debug)]
pub struct StoredMmrHistoryV2ByIdParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String,
    /// Platform (pc, console)
    pub platform: String,
    /// Player UUID
    pub puuid: String,
    /// Number of results (optional)
    pub size: Option<i32>
}

/// struct for passing parameters to the method [`version`]
#[derive(Clone, Debug)]
pub struct VersionParams {
    /// Region/affinity (e.g., na, eu, ap, kr)
    pub affinity: String
}

/// struct for passing parameters to the method [`website`]
#[derive(Clone, Debug)]
pub struct WebsiteParams {
    /// Country code (e.g., en-us, de-de)
    pub country_code: String,
    /// Category filter (optional)
    pub category: Option<String>
}

/// struct for passing parameters to the method [`website_by_id`]
#[derive(Clone, Debug)]
pub struct WebsiteByIdParams {
    /// Database ID of the website entry
    pub db_id: String,
    /// Country code (e.g., en-us, de-de)
    pub country_code: String
}


/// struct for typed errors of method [`crosshair`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CrosshairError {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_event_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsEventV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_events_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsEventsV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_match_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsMatchV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_player_matches_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsPlayerMatchesV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_player_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsPlayerV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_schedules_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsSchedulesV1Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_team_matches_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsTeamMatchesV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_team_transactions_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsTeamTransactionsV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`esports_team_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EsportsTeamV2Error {
    Status400(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_by_id_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountByIdV1Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_by_id_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountByIdV2Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountV1Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_account_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAccountV2Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_content_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContentV1Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_matches_v3_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMatchesV3ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_matches_v3_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMatchesV3ByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_matches_v4_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMatchesV4ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_matches_v4_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMatchesV4ByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_history_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrHistoryByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_history_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrHistoryByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_history_v2_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrHistoryV2ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_history_v2_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrHistoryV2ByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_v1_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrV1ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_v1_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrV1ByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_v2_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrV2ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_v2_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrV2ByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_v3_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrV3ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mmr_v3_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMmrV3ByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leaderboard_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaderboardV1Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leaderboard_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaderboardV2Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leaderboard_v3`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaderboardV3Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`match_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchV2Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`match_v4`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchV4Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`premier_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PremierByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`premier_by_id_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PremierByIdHistoryError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`premier_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PremierByNameError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`premier_by_name_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PremierByNameHistoryError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`premier_leaderboard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PremierLeaderboardError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`premier_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PremierSearchError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`queue_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueueStatusError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`raw`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RawError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatusError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_featured`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreFeaturedError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`store_offers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoreOffersError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stored_matches`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoredMatchesError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stored_matches_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoredMatchesByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stored_mmr_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoredMmrHistoryError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stored_mmr_history_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoredMmrHistoryByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stored_mmr_history_v2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoredMmrHistoryV2Error {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stored_mmr_history_v2_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoredMmrHistoryV2ByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VersionError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`website`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebsiteError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`website_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebsiteByIdError {
    Status400(models::SendError),
    Status404(models::SendError),
    Status500(models::SendError),
    UnknownValue(serde_json::Value),
}


pub async fn crosshair(configuration: &configuration::Configuration, params: CrosshairParams) -> Result<(), Error<CrosshairError>> {

    let uri_str = format!("{}/valorant/v1/crosshair/generate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CrosshairError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_event_v2(configuration: &configuration::Configuration, params: EsportsEventV2Params) -> Result<models::EsportsV2EventResponse, Error<EsportsEventV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/events/{event_id}/matches", configuration.base_path, event_id=params.event_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2EventResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2EventResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsEventV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_events_v2(configuration: &configuration::Configuration, params: EsportsEventsV2Params) -> Result<models::EsportsV2EventsResponse, Error<EsportsEventsV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/events", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.r#type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2EventsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2EventsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsEventsV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_match_v2(configuration: &configuration::Configuration, params: EsportsMatchV2Params) -> Result<models::EsportsV2MatchesResponse, Error<EsportsMatchV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/matches/{match_id}", configuration.base_path, match_id=params.match_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2MatchesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2MatchesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsMatchV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_player_matches_v2(configuration: &configuration::Configuration, params: EsportsPlayerMatchesV2Params) -> Result<models::EsportsV2PlayerMatchesResponse, Error<EsportsPlayerMatchesV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/players/{player}/matches", configuration.base_path, player=params.player);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2PlayerMatchesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2PlayerMatchesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsPlayerMatchesV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_player_v2(configuration: &configuration::Configuration, params: EsportsPlayerV2Params) -> Result<models::EsportsV2PlayerResponse, Error<EsportsPlayerV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/players/{player_id}", configuration.base_path, player=params.player);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.timespan {
        req_builder = req_builder.query(&[("timespan", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2PlayerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2PlayerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsPlayerV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_schedules_v1(configuration: &configuration::Configuration, params: EsportsSchedulesV1Params) -> Result<models::EsportsV1Response, Error<EsportsSchedulesV1Error>> {

    let uri_str = format!("{}/valorant/v1/esports/schedule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.region {
        req_builder = req_builder.query(&[("region", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.league {
        req_builder = req_builder.query(&[("league", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsSchedulesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_team_matches_v2(configuration: &configuration::Configuration, params: EsportsTeamMatchesV2Params) -> Result<models::EsportsV2TeamMatchListResponse, Error<EsportsTeamMatchesV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/teams/{team_id}/matches", configuration.base_path, team_id=params.team_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2TeamMatchListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2TeamMatchListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsTeamMatchesV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_team_transactions_v2(configuration: &configuration::Configuration, params: EsportsTeamTransactionsV2Params) -> Result<models::EsportsV2TeamTransactionsResponse, Error<EsportsTeamTransactionsV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/teams/{team_id}/transactions", configuration.base_path, team_id=params.team_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2TeamTransactionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2TeamTransactionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsTeamTransactionsV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn esports_team_v2(configuration: &configuration::Configuration, params: EsportsTeamV2Params) -> Result<models::EsportsV2TeamResponse, Error<EsportsTeamV2Error>> {

    let uri_str = format!("{}/valorant/v2/esports/vlr/teams/{team_id}", configuration.base_path, team_id=params.team_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EsportsV2TeamResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EsportsV2TeamResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EsportsTeamV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_by_id_v1(configuration: &configuration::Configuration, params: GetAccountByIdV1Params) -> Result<models::AccountV1Response, Error<GetAccountByIdV1Error>> {

    let uri_str = format!("{}/valorant/v1/by-puuid/account/{puuid}", configuration.base_path, puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountByIdV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_by_id_v2(configuration: &configuration::Configuration, params: GetAccountByIdV2Params) -> Result<models::AccountV2Response, Error<GetAccountByIdV2Error>> {

    let uri_str = format!("{}/valorant/v2/by-puuid/account/{puuid}", configuration.base_path, puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountV2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountV2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountByIdV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_v1(configuration: &configuration::Configuration, params: GetAccountV1Params) -> Result<models::AccountV1Response, Error<GetAccountV1Error>> {

    let uri_str = format!("{}/valorant/v1/account/{name}/{tag}", configuration.base_path, name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_account_v2(configuration: &configuration::Configuration, params: GetAccountV2Params) -> Result<models::AccountV2Response, Error<GetAccountV2Error>> {

    let uri_str = format!("{}/valorant/v2/account/{name}/{tag}", configuration.base_path, name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.force {
        req_builder = req_builder.query(&[("force", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountV2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountV2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAccountV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_content_v1(configuration: &configuration::Configuration, params: GetContentV1Params) -> Result<models::ContentV1Response, Error<GetContentV1Error>> {

    let uri_str = format!("{}/valorant/v1/content", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContentV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_matches_v3_by_id(configuration: &configuration::Configuration, params: GetMatchesV3ByIdParams) -> Result<models::MatchesV3ListResponse, Error<GetMatchesV3ByIdError>> {

    let uri_str = format!("{}/valorant/v3/by-puuid/matches/{affinity}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.map {
        req_builder = req_builder.query(&[("map", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchesV3ListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchesV3ListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMatchesV3ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_matches_v3_by_name(configuration: &configuration::Configuration, params: GetMatchesV3ByNameParams) -> Result<models::MatchesV3ListResponse, Error<GetMatchesV3ByNameError>> {

    let uri_str = format!("{}/valorant/v3/matches/{affinity}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.map {
        req_builder = req_builder.query(&[("map", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchesV3ListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchesV3ListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMatchesV3ByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_matches_v4_by_id(configuration: &configuration::Configuration, params: GetMatchesV4ByIdParams) -> Result<models::MatchesV4HistoryResponse, Error<GetMatchesV4ByIdError>> {

    let uri_str = format!("{}/valorant/v4/by-puuid/matches/{affinity}/{platform}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.map {
        req_builder = req_builder.query(&[("map", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchesV4HistoryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchesV4HistoryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMatchesV4ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_matches_v4_by_name(configuration: &configuration::Configuration, params: GetMatchesV4ByNameParams) -> Result<models::MatchesV4HistoryResponse, Error<GetMatchesV4ByNameError>> {

    let uri_str = format!("{}/valorant/v4/matches/{affinity}/{platform}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.map {
        req_builder = req_builder.query(&[("map", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchesV4HistoryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchesV4HistoryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMatchesV4ByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_history_by_id(configuration: &configuration::Configuration, params: GetMmrHistoryByIdParams) -> Result<models::MmrHistoryV1Response, Error<GetMmrHistoryByIdError>> {

    let uri_str = format!("{}/valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MmrHistoryV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MmrHistoryV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrHistoryByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_history_by_name(configuration: &configuration::Configuration, params: GetMmrHistoryByNameParams) -> Result<models::MmrHistoryV1Response, Error<GetMmrHistoryByNameError>> {

    let uri_str = format!("{}/valorant/v1/mmr-history/{affinity}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MmrHistoryV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MmrHistoryV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrHistoryByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_history_v2_by_id(configuration: &configuration::Configuration, params: GetMmrHistoryV2ByIdParams) -> Result<models::MmrHistoryV2Response, Error<GetMmrHistoryV2ByIdError>> {

    let uri_str = format!("{}/valorant/v2/by-puuid/mmr-history/{affinity}/{platform}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MmrHistoryV2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MmrHistoryV2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrHistoryV2ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_history_v2_by_name(configuration: &configuration::Configuration, params: GetMmrHistoryV2ByNameParams) -> Result<models::MmrHistoryV2Response, Error<GetMmrHistoryV2ByNameError>> {

    let uri_str = format!("{}/valorant/v2/mmr-history/{affinity}/{platform}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MmrHistoryV2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MmrHistoryV2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrHistoryV2ByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_v1_by_id(configuration: &configuration::Configuration, params: GetMmrV1ByIdParams) -> Result<models::Mmrv1Response, Error<GetMmrV1ByIdError>> {

    let uri_str = format!("{}/valorant/v1/by-puuid/mmr/{affinity}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Mmrv1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Mmrv1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrV1ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_v1_by_name(configuration: &configuration::Configuration, params: GetMmrV1ByNameParams) -> Result<models::Mmrv1Response, Error<GetMmrV1ByNameError>> {

    let uri_str = format!("{}/valorant/v1/mmr/{affinity}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Mmrv1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Mmrv1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrV1ByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_v2_by_id(configuration: &configuration::Configuration, params: GetMmrV2ByIdParams) -> Result<models::Mmrv2Response, Error<GetMmrV2ByIdError>> {

    let uri_str = format!("{}/valorant/v2/by-puuid/mmr/{affinity}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Mmrv2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Mmrv2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrV2ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_v2_by_name(configuration: &configuration::Configuration, params: GetMmrV2ByNameParams) -> Result<models::Mmrv2Response, Error<GetMmrV2ByNameError>> {

    let uri_str = format!("{}/valorant/v2/mmr/{affinity}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Mmrv2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Mmrv2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrV2ByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_v3_by_id(configuration: &configuration::Configuration, params: GetMmrV3ByIdParams) -> Result<models::Mmrv3Response, Error<GetMmrV3ByIdError>> {

    let uri_str = format!("{}/valorant/v3/by-puuid/mmr/{affinity}/{platform}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Mmrv3Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Mmrv3Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrV3ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_mmr_v3_by_name(configuration: &configuration::Configuration, params: GetMmrV3ByNameParams) -> Result<models::Mmrv3Response, Error<GetMmrV3ByNameError>> {

    let uri_str = format!("{}/valorant/v3/mmr/{affinity}/{platform}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Mmrv3Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Mmrv3Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMmrV3ByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn leaderboard_v1(configuration: &configuration::Configuration, params: LeaderboardV1Params) -> Result<serde_json::Value, Error<LeaderboardV1Error>> {

    let uri_str = format!("{}/valorant/v1/leaderboard/{affinity}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.season {
        req_builder = req_builder.query(&[("season", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaderboardV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn leaderboard_v2(configuration: &configuration::Configuration, params: LeaderboardV2Params) -> Result<models::LeaderboardV2Response, Error<LeaderboardV2Error>> {

    let uri_str = format!("{}/valorant/v2/leaderboard/{affinity}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.season {
        req_builder = req_builder.query(&[("season", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.puuid {
        req_builder = req_builder.query(&[("puuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardV2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardV2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaderboardV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn leaderboard_v3(configuration: &configuration::Configuration, params: LeaderboardV3Params) -> Result<models::LeaderboardV3Response, Error<LeaderboardV3Error>> {

    let uri_str = format!("{}/valorant/v3/leaderboard/{affinity}/{platform}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.season {
        req_builder = req_builder.query(&[("season", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardV3Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardV3Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaderboardV3Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn match_v2(configuration: &configuration::Configuration, params: MatchV2Params) -> Result<models::MatchesV2Response, Error<MatchV2Error>> {

    let uri_str = format!("{}/valorant/v2/match/{match_id}", configuration.base_path, match_id=crate::apis::urlencode(params.match_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchesV2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchesV2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MatchV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn match_v4(configuration: &configuration::Configuration, params: MatchV4Params) -> Result<models::MatchesV4Response, Error<MatchV4Error>> {

    let uri_str = format!("{}/valorant/v4/match/{affinity}/{match_id}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), match_id=crate::apis::urlencode(params.match_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchesV4Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchesV4Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MatchV4Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn premier_by_id(configuration: &configuration::Configuration, params: PremierByIdParams) -> Result<models::PremierTeamV1Response, Error<PremierByIdError>> {

    let uri_str = format!("{}/valorant/v1/premier/{id}", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PremierTeamV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PremierTeamV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PremierByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn premier_by_id_history(configuration: &configuration::Configuration, params: PremierByIdHistoryParams) -> Result<models::PremierTeamV1Response, Error<PremierByIdHistoryError>> {

    let uri_str = format!("{}/valorant/v1/premier/{id}/history", configuration.base_path, id=crate::apis::urlencode(params.id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PremierTeamV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PremierTeamV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PremierByIdHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn premier_by_name(configuration: &configuration::Configuration, params: PremierByNameParams) -> Result<models::PremierTeamV1Response, Error<PremierByNameError>> {

    let uri_str = format!("{}/valorant/v1/premier/{name}/{tag}", configuration.base_path, name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PremierTeamV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PremierTeamV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PremierByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn premier_by_name_history(configuration: &configuration::Configuration, params: PremierByNameHistoryParams) -> Result<models::PremierTeamHistoryV1Response, Error<PremierByNameHistoryError>> {

    let uri_str = format!("{}/valorant/v1/premier/{name}/{tag}/history", configuration.base_path, name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PremierTeamHistoryV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PremierTeamHistoryV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PremierByNameHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn premier_leaderboard(configuration: &configuration::Configuration, params: PremierLeaderboardParams) -> Result<models::PremierSearchResponse, Error<PremierLeaderboardError>> {

    let uri_str = format!("{}/valorant/v1/premier/leaderboard/{affinity}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.conference {
        req_builder = req_builder.query(&[("conference", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.division {
        req_builder = req_builder.query(&[("division", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PremierSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PremierSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PremierLeaderboardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn premier_search(configuration: &configuration::Configuration, params: PremierSearchParams) -> Result<models::PremierSearchResponse, Error<PremierSearchError>> {

    let uri_str = format!("{}/valorant/v1/premier/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PremierSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PremierSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PremierSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn queue_status(configuration: &configuration::Configuration, params: QueueStatusParams) -> Result<models::QueueStatusV1, Error<QueueStatusError>> {

    let uri_str = format!("{}/valorant/v1/queue-status/{affinity}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::QueueStatusV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::QueueStatusV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueueStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn raw(configuration: &configuration::Configuration, params: RawParams) -> Result<models::RawV1Response, Error<RawError>> {

    let uri_str = format!("{}/valorant/v1/raw", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.raw_v1_payload);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RawV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RawV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RawError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn status(configuration: &configuration::Configuration, params: StatusParams) -> Result<models::StatusV1, Error<StatusError>> {

    let uri_str = format!("{}/valorant/v1/status/{affinity}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatusV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatusV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn store_featured(configuration: &configuration::Configuration, params: StoreFeaturedParams) -> Result<models::StoreFeaturedV1, Error<StoreFeaturedError>> {

    let uri_str = format!("{}/valorant/{version}/store-featured", configuration.base_path, version=crate::apis::urlencode(params.version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoreFeaturedV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoreFeaturedV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreFeaturedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn store_offers(configuration: &configuration::Configuration, params: StoreOffersParams) -> Result<models::StoreOffersV1Response, Error<StoreOffersError>> {

    let uri_str = format!("{}/valorant/{version}/store-offers", configuration.base_path, version=crate::apis::urlencode(params.version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoreOffersV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoreOffersV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoreOffersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stored_matches(configuration: &configuration::Configuration, params: StoredMatchesParams) -> Result<models::StoredMatchesResponse, Error<StoredMatchesError>> {

    let uri_str = format!("{}/valorant/v1/stored-matches/{affinity}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.map {
        req_builder = req_builder.query(&[("map", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoredMatchesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoredMatchesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoredMatchesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stored_matches_by_id(configuration: &configuration::Configuration, params: StoredMatchesByIdParams) -> Result<models::StoredMatchesResponse, Error<StoredMatchesByIdError>> {

    let uri_str = format!("{}/valorant/v1/by-puuid/stored-matches/{affinity}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.map {
        req_builder = req_builder.query(&[("map", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoredMatchesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoredMatchesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoredMatchesByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stored_mmr_history(configuration: &configuration::Configuration, params: StoredMmrHistoryParams) -> Result<models::StoredMmrResponse, Error<StoredMmrHistoryError>> {

    let uri_str = format!("{}/valorant/v1/stored-mmr-history/{affinity}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoredMmrResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoredMmrResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoredMmrHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stored_mmr_history_by_id(configuration: &configuration::Configuration, params: StoredMmrHistoryByIdParams) -> Result<models::StoredMmrResponse, Error<StoredMmrHistoryByIdError>> {

    let uri_str = format!("{}/valorant/v1/by-puuid/stored-mmr-history/{affinity}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoredMmrResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoredMmrResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoredMmrHistoryByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stored_mmr_history_v2(configuration: &configuration::Configuration, params: StoredMmrHistoryV2Params) -> Result<models::StoredMmrv2Response, Error<StoredMmrHistoryV2Error>> {

    let uri_str = format!("{}/valorant/v2/stored-mmr-history/{affinity}/{platform}/{name}/{tag}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), name=crate::apis::urlencode(params.name), tag=crate::apis::urlencode(params.tag));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoredMmrv2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoredMmrv2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoredMmrHistoryV2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stored_mmr_history_v2_by_id(configuration: &configuration::Configuration, params: StoredMmrHistoryV2ByIdParams) -> Result<models::StoredMmrv2Response, Error<StoredMmrHistoryV2ByIdError>> {

    let uri_str = format!("{}/valorant/v2/by-puuid/stored-mmr-history/{affinity}/{platform}/{puuid}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity), platform=crate::apis::urlencode(params.platform), puuid=crate::apis::urlencode(params.puuid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StoredMmrv2Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StoredMmrv2Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StoredMmrHistoryV2ByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn version(configuration: &configuration::Configuration, params: VersionParams) -> Result<models::VersionV1Response, Error<VersionError>> {

    let uri_str = format!("{}/valorant/v1/version/{affinity}", configuration.base_path, affinity=crate::apis::urlencode(params.affinity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VersionV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VersionV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn website(configuration: &configuration::Configuration, params: WebsiteParams) -> Result<models::WebsiteV1Response, Error<WebsiteError>> {

    let uri_str = format!("{}/valorant/v1/website/{country_code}", configuration.base_path, country_code=crate::apis::urlencode(params.country_code));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.category {
        req_builder = req_builder.query(&[("category", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebsiteV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebsiteV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebsiteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn website_by_id(configuration: &configuration::Configuration, params: WebsiteByIdParams) -> Result<models::WebsiteByIdV1Response, Error<WebsiteByIdError>> {

    let uri_str = format!("{}/valorant/v1/website/{country_code}/{db_id}", configuration.base_path, db_id=crate::apis::urlencode(params.db_id), country_code=crate::apis::urlencode(params.country_code));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebsiteByIdV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebsiteByIdV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WebsiteByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

