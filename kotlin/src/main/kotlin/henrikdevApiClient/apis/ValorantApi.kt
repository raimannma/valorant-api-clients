/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package henrikdevApiClient.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import henrikdevApiClient.models.AccountV1Response
import henrikdevApiClient.models.AccountV2Response
import henrikdevApiClient.models.ContentV1Response
import henrikdevApiClient.models.EsportsV1Response
import henrikdevApiClient.models.LeaderboardV2Response
import henrikdevApiClient.models.LeaderboardV3Response
import henrikdevApiClient.models.MMRHistoryV1Response
import henrikdevApiClient.models.MMRHistoryV2Response
import henrikdevApiClient.models.MMRV1Response
import henrikdevApiClient.models.MMRV2Response
import henrikdevApiClient.models.MMRV3Response
import henrikdevApiClient.models.MatchMode
import henrikdevApiClient.models.MatchesV2Response
import henrikdevApiClient.models.MatchesV3ListResponse
import henrikdevApiClient.models.MatchesV4HistoryResponse
import henrikdevApiClient.models.MatchesV4Response
import henrikdevApiClient.models.PremierSearchResponse
import henrikdevApiClient.models.PremierTeamHistoryV1Response
import henrikdevApiClient.models.PremierTeamV1Response
import henrikdevApiClient.models.QueueStatusV1
import henrikdevApiClient.models.RawV1Payload
import henrikdevApiClient.models.RawV1Response
import henrikdevApiClient.models.SendError
import henrikdevApiClient.models.StatusV1
import henrikdevApiClient.models.StoreFeaturedV1
import henrikdevApiClient.models.StoreOffersV1Response
import henrikdevApiClient.models.StoredMMRResponse
import henrikdevApiClient.models.StoredMMRV2Response
import henrikdevApiClient.models.StoredMatchesResponse
import henrikdevApiClient.models.VersionV1Response
import henrikdevApiClient.models.WebsiteByIdV1Response
import henrikdevApiClient.models.WebsiteV1Response

import com.squareup.moshi.Json

import henrikdevApiClient.infrastructure.ApiClient
import henrikdevApiClient.infrastructure.ApiResponse
import henrikdevApiClient.infrastructure.ClientException
import henrikdevApiClient.infrastructure.ClientError
import henrikdevApiClient.infrastructure.ServerException
import henrikdevApiClient.infrastructure.ServerError
import henrikdevApiClient.infrastructure.MultiValueMap
import henrikdevApiClient.infrastructure.PartConfig
import henrikdevApiClient.infrastructure.RequestConfig
import henrikdevApiClient.infrastructure.RequestMethod
import henrikdevApiClient.infrastructure.ResponseType
import henrikdevApiClient.infrastructure.Success
import henrikdevApiClient.infrastructure.toMultiValue

class ValorantApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.henrikdev.xyz")
        }
    }

    /**
     * GET /valorant/v1/crosshair/generate
     * 
     * 
     * @param id Crosshair code (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun crosshair(id: kotlin.String? = null) : Unit {
        val localVarResponse = crosshairWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/crosshair/generate
     * 
     * 
     * @param id Crosshair code (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun crosshairWithHttpInfo(id: kotlin.String?) : ApiResponse<Unit?> {
        val localVariableConfig = crosshairRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation crosshair
     *
     * @param id Crosshair code (optional)
     * @return RequestConfig
     */
    fun crosshairRequestConfig(id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/crosshair/generate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/esports/schedule
     * 
     * 
     * @param region Region filter (optional) (optional)
     * @return EsportsV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun esportsSchedulesV1(region: kotlin.String? = null) : EsportsV1Response {
        val localVarResponse = esportsSchedulesV1WithHttpInfo(region = region)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EsportsV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/esports/schedule
     * 
     * 
     * @param region Region filter (optional) (optional)
     * @return ApiResponse<EsportsV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun esportsSchedulesV1WithHttpInfo(region: kotlin.String?) : ApiResponse<EsportsV1Response?> {
        val localVariableConfig = esportsSchedulesV1RequestConfig(region = region)

        return request<Unit, EsportsV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation esportsSchedulesV1
     *
     * @param region Region filter (optional) (optional)
     * @return RequestConfig
     */
    fun esportsSchedulesV1RequestConfig(region: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (region != null) {
                    put("region", listOf(region.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/esports/schedule",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/by-puuid/account/{puuid}
     * 
     * 
     * @param puuid Player UUID
     * @param force Bypass cache and refresh (optional) (optional)
     * @return AccountV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountByIdV1(puuid: kotlin.String, force: kotlin.Boolean? = null) : AccountV1Response {
        val localVarResponse = getAccountByIdV1WithHttpInfo(puuid = puuid, force = force)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/by-puuid/account/{puuid}
     * 
     * 
     * @param puuid Player UUID
     * @param force Bypass cache and refresh (optional) (optional)
     * @return ApiResponse<AccountV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountByIdV1WithHttpInfo(puuid: kotlin.String, force: kotlin.Boolean?) : ApiResponse<AccountV1Response?> {
        val localVariableConfig = getAccountByIdV1RequestConfig(puuid = puuid, force = force)

        return request<Unit, AccountV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountByIdV1
     *
     * @param puuid Player UUID
     * @param force Bypass cache and refresh (optional) (optional)
     * @return RequestConfig
     */
    fun getAccountByIdV1RequestConfig(puuid: kotlin.String, force: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (force != null) {
                    put("force", listOf(force.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/by-puuid/account/{puuid}".replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/by-puuid/account/{puuid}
     * 
     * 
     * @param puuid Player UUID
     * @param force Bypass cache and refresh (optional) (optional)
     * @return AccountV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountByIdV2(puuid: kotlin.String, force: kotlin.Boolean? = null) : AccountV2Response {
        val localVarResponse = getAccountByIdV2WithHttpInfo(puuid = puuid, force = force)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/by-puuid/account/{puuid}
     * 
     * 
     * @param puuid Player UUID
     * @param force Bypass cache and refresh (optional) (optional)
     * @return ApiResponse<AccountV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountByIdV2WithHttpInfo(puuid: kotlin.String, force: kotlin.Boolean?) : ApiResponse<AccountV2Response?> {
        val localVariableConfig = getAccountByIdV2RequestConfig(puuid = puuid, force = force)

        return request<Unit, AccountV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountByIdV2
     *
     * @param puuid Player UUID
     * @param force Bypass cache and refresh (optional) (optional)
     * @return RequestConfig
     */
    fun getAccountByIdV2RequestConfig(puuid: kotlin.String, force: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (force != null) {
                    put("force", listOf(force.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/by-puuid/account/{puuid}".replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/account/{name}/{tag}
     * 
     * 
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param force Bypass cache and refresh (optional) (optional)
     * @return AccountV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountV1(name: kotlin.String, tag: kotlin.String, force: kotlin.Boolean? = null) : AccountV1Response {
        val localVarResponse = getAccountV1WithHttpInfo(name = name, tag = tag, force = force)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/account/{name}/{tag}
     * 
     * 
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param force Bypass cache and refresh (optional) (optional)
     * @return ApiResponse<AccountV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountV1WithHttpInfo(name: kotlin.String, tag: kotlin.String, force: kotlin.Boolean?) : ApiResponse<AccountV1Response?> {
        val localVariableConfig = getAccountV1RequestConfig(name = name, tag = tag, force = force)

        return request<Unit, AccountV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountV1
     *
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param force Bypass cache and refresh (optional) (optional)
     * @return RequestConfig
     */
    fun getAccountV1RequestConfig(name: kotlin.String, tag: kotlin.String, force: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (force != null) {
                    put("force", listOf(force.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/account/{name}/{tag}".replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/account/{name}/{tag}
     * 
     * 
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param force Bypass cache and refresh (optional) (optional)
     * @return AccountV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountV2(name: kotlin.String, tag: kotlin.String, force: kotlin.Boolean? = null) : AccountV2Response {
        val localVarResponse = getAccountV2WithHttpInfo(name = name, tag = tag, force = force)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/account/{name}/{tag}
     * 
     * 
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param force Bypass cache and refresh (optional) (optional)
     * @return ApiResponse<AccountV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountV2WithHttpInfo(name: kotlin.String, tag: kotlin.String, force: kotlin.Boolean?) : ApiResponse<AccountV2Response?> {
        val localVariableConfig = getAccountV2RequestConfig(name = name, tag = tag, force = force)

        return request<Unit, AccountV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAccountV2
     *
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param force Bypass cache and refresh (optional) (optional)
     * @return RequestConfig
     */
    fun getAccountV2RequestConfig(name: kotlin.String, tag: kotlin.String, force: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (force != null) {
                    put("force", listOf(force.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/account/{name}/{tag}".replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/content
     * 
     * 
     * @param locale Locale code (e.g., en-US, de-DE) - optional (optional)
     * @return ContentV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getContentV1(locale: kotlin.String? = null) : ContentV1Response {
        val localVarResponse = getContentV1WithHttpInfo(locale = locale)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ContentV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/content
     * 
     * 
     * @param locale Locale code (e.g., en-US, de-DE) - optional (optional)
     * @return ApiResponse<ContentV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getContentV1WithHttpInfo(locale: kotlin.String?) : ApiResponse<ContentV1Response?> {
        val localVariableConfig = getContentV1RequestConfig(locale = locale)

        return request<Unit, ContentV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getContentV1
     *
     * @param locale Locale code (e.g., en-US, de-DE) - optional (optional)
     * @return RequestConfig
     */
    fun getContentV1RequestConfig(locale: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (locale != null) {
                    put("locale", listOf(locale.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/content",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v3/by-puuid/matches/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return MatchesV3ListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMatchesV3ById(affinity: kotlin.String, puuid: kotlin.String, mode: kotlin.String? = null, map: kotlin.String? = null, size: kotlin.Int? = null) : MatchesV3ListResponse {
        val localVarResponse = getMatchesV3ByIdWithHttpInfo(affinity = affinity, puuid = puuid, mode = mode, map = map, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchesV3ListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v3/by-puuid/matches/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<MatchesV3ListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMatchesV3ByIdWithHttpInfo(affinity: kotlin.String, puuid: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?) : ApiResponse<MatchesV3ListResponse?> {
        val localVariableConfig = getMatchesV3ByIdRequestConfig(affinity = affinity, puuid = puuid, mode = mode, map = map, size = size)

        return request<Unit, MatchesV3ListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMatchesV3ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun getMatchesV3ByIdRequestConfig(affinity: kotlin.String, puuid: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (map != null) {
                    put("map", listOf(map.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v3/by-puuid/matches/{affinity}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v3/matches/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return MatchesV3ListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMatchesV3ByName(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: MatchMode? = null, map: kotlin.String? = null, size: kotlin.Int? = null) : MatchesV3ListResponse {
        val localVarResponse = getMatchesV3ByNameWithHttpInfo(affinity = affinity, name = name, tag = tag, mode = mode, map = map, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchesV3ListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v3/matches/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<MatchesV3ListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMatchesV3ByNameWithHttpInfo(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: MatchMode?, map: kotlin.String?, size: kotlin.Int?) : ApiResponse<MatchesV3ListResponse?> {
        val localVariableConfig = getMatchesV3ByNameRequestConfig(affinity = affinity, name = name, tag = tag, mode = mode, map = map, size = size)

        return request<Unit, MatchesV3ListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMatchesV3ByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun getMatchesV3ByNameRequestConfig(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: MatchMode?, map: kotlin.String?, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (map != null) {
                    put("map", listOf(map.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v3/matches/{affinity}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v4/by-puuid/matches/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @param start Start index for pagination (optional) (optional)
     * @return MatchesV4HistoryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMatchesV4ById(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String, mode: kotlin.String? = null, map: kotlin.String? = null, size: kotlin.Int? = null, start: kotlin.Int? = null) : MatchesV4HistoryResponse {
        val localVarResponse = getMatchesV4ByIdWithHttpInfo(affinity = affinity, platform = platform, puuid = puuid, mode = mode, map = map, size = size, start = start)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchesV4HistoryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v4/by-puuid/matches/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @param start Start index for pagination (optional) (optional)
     * @return ApiResponse<MatchesV4HistoryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMatchesV4ByIdWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?, start: kotlin.Int?) : ApiResponse<MatchesV4HistoryResponse?> {
        val localVariableConfig = getMatchesV4ByIdRequestConfig(affinity = affinity, platform = platform, puuid = puuid, mode = mode, map = map, size = size, start = start)

        return request<Unit, MatchesV4HistoryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMatchesV4ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @param start Start index for pagination (optional) (optional)
     * @return RequestConfig
     */
    fun getMatchesV4ByIdRequestConfig(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?, start: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (map != null) {
                    put("map", listOf(map.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v4/by-puuid/matches/{affinity}/{platform}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v4/matches/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @param start Start index for pagination (optional) (optional)
     * @return MatchesV4HistoryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMatchesV4ByName(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: kotlin.String? = null, map: kotlin.String? = null, size: kotlin.Int? = null, start: kotlin.Int? = null) : MatchesV4HistoryResponse {
        val localVarResponse = getMatchesV4ByNameWithHttpInfo(affinity = affinity, platform = platform, name = name, tag = tag, mode = mode, map = map, size = size, start = start)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchesV4HistoryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v4/matches/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @param start Start index for pagination (optional) (optional)
     * @return ApiResponse<MatchesV4HistoryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMatchesV4ByNameWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?, start: kotlin.Int?) : ApiResponse<MatchesV4HistoryResponse?> {
        val localVariableConfig = getMatchesV4ByNameRequestConfig(affinity = affinity, platform = platform, name = name, tag = tag, mode = mode, map = map, size = size, start = start)

        return request<Unit, MatchesV4HistoryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMatchesV4ByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @param start Start index for pagination (optional) (optional)
     * @return RequestConfig
     */
    fun getMatchesV4ByNameRequestConfig(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?, start: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (map != null) {
                    put("map", listOf(map.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v4/matches/{affinity}/{platform}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return MMRHistoryV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrHistoryById(affinity: kotlin.String, puuid: kotlin.String) : MMRHistoryV1Response {
        val localVarResponse = getMmrHistoryByIdWithHttpInfo(affinity = affinity, puuid = puuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRHistoryV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return ApiResponse<MMRHistoryV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrHistoryByIdWithHttpInfo(affinity: kotlin.String, puuid: kotlin.String) : ApiResponse<MMRHistoryV1Response?> {
        val localVariableConfig = getMmrHistoryByIdRequestConfig(affinity = affinity, puuid = puuid)

        return request<Unit, MMRHistoryV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrHistoryById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return RequestConfig
     */
    fun getMmrHistoryByIdRequestConfig(affinity: kotlin.String, puuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/mmr-history/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return MMRHistoryV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrHistoryByName(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : MMRHistoryV1Response {
        val localVarResponse = getMmrHistoryByNameWithHttpInfo(affinity = affinity, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRHistoryV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/mmr-history/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return ApiResponse<MMRHistoryV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrHistoryByNameWithHttpInfo(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : ApiResponse<MMRHistoryV1Response?> {
        val localVariableConfig = getMmrHistoryByNameRequestConfig(affinity = affinity, name = name, tag = tag)

        return request<Unit, MMRHistoryV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrHistoryByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return RequestConfig
     */
    fun getMmrHistoryByNameRequestConfig(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/mmr-history/{affinity}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/by-puuid/mmr-history/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @return MMRHistoryV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrHistoryV2ById(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String) : MMRHistoryV2Response {
        val localVarResponse = getMmrHistoryV2ByIdWithHttpInfo(affinity = affinity, platform = platform, puuid = puuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRHistoryV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/by-puuid/mmr-history/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @return ApiResponse<MMRHistoryV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrHistoryV2ByIdWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String) : ApiResponse<MMRHistoryV2Response?> {
        val localVariableConfig = getMmrHistoryV2ByIdRequestConfig(affinity = affinity, platform = platform, puuid = puuid)

        return request<Unit, MMRHistoryV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrHistoryV2ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @return RequestConfig
     */
    fun getMmrHistoryV2ByIdRequestConfig(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/by-puuid/mmr-history/{affinity}/{platform}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/mmr-history/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return MMRHistoryV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrHistoryV2ByName(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String) : MMRHistoryV2Response {
        val localVarResponse = getMmrHistoryV2ByNameWithHttpInfo(affinity = affinity, platform = platform, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRHistoryV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/mmr-history/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return ApiResponse<MMRHistoryV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrHistoryV2ByNameWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String) : ApiResponse<MMRHistoryV2Response?> {
        val localVariableConfig = getMmrHistoryV2ByNameRequestConfig(affinity = affinity, platform = platform, name = name, tag = tag)

        return request<Unit, MMRHistoryV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrHistoryV2ByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return RequestConfig
     */
    fun getMmrHistoryV2ByNameRequestConfig(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/mmr-history/{affinity}/{platform}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/by-puuid/mmr/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return MMRV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrV1ById(affinity: kotlin.String, puuid: kotlin.String) : MMRV1Response {
        val localVarResponse = getMmrV1ByIdWithHttpInfo(affinity = affinity, puuid = puuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/by-puuid/mmr/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return ApiResponse<MMRV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrV1ByIdWithHttpInfo(affinity: kotlin.String, puuid: kotlin.String) : ApiResponse<MMRV1Response?> {
        val localVariableConfig = getMmrV1ByIdRequestConfig(affinity = affinity, puuid = puuid)

        return request<Unit, MMRV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrV1ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return RequestConfig
     */
    fun getMmrV1ByIdRequestConfig(affinity: kotlin.String, puuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/by-puuid/mmr/{affinity}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/mmr/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return MMRV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrV1ByName(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : MMRV1Response {
        val localVarResponse = getMmrV1ByNameWithHttpInfo(affinity = affinity, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/mmr/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return ApiResponse<MMRV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrV1ByNameWithHttpInfo(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : ApiResponse<MMRV1Response?> {
        val localVariableConfig = getMmrV1ByNameRequestConfig(affinity = affinity, name = name, tag = tag)

        return request<Unit, MMRV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrV1ByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return RequestConfig
     */
    fun getMmrV1ByNameRequestConfig(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/mmr/{affinity}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/by-puuid/mmr/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return MMRV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrV2ById(affinity: kotlin.String, puuid: kotlin.String) : MMRV2Response {
        val localVarResponse = getMmrV2ByIdWithHttpInfo(affinity = affinity, puuid = puuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/by-puuid/mmr/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return ApiResponse<MMRV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrV2ByIdWithHttpInfo(affinity: kotlin.String, puuid: kotlin.String) : ApiResponse<MMRV2Response?> {
        val localVariableConfig = getMmrV2ByIdRequestConfig(affinity = affinity, puuid = puuid)

        return request<Unit, MMRV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrV2ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @return RequestConfig
     */
    fun getMmrV2ByIdRequestConfig(affinity: kotlin.String, puuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/by-puuid/mmr/{affinity}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/mmr/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return MMRV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrV2ByName(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : MMRV2Response {
        val localVarResponse = getMmrV2ByNameWithHttpInfo(affinity = affinity, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/mmr/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return ApiResponse<MMRV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrV2ByNameWithHttpInfo(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : ApiResponse<MMRV2Response?> {
        val localVariableConfig = getMmrV2ByNameRequestConfig(affinity = affinity, name = name, tag = tag)

        return request<Unit, MMRV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrV2ByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return RequestConfig
     */
    fun getMmrV2ByNameRequestConfig(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/mmr/{affinity}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v3/by-puuid/mmr/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @return MMRV3Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrV3ById(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String) : MMRV3Response {
        val localVarResponse = getMmrV3ByIdWithHttpInfo(affinity = affinity, platform = platform, puuid = puuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRV3Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v3/by-puuid/mmr/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @return ApiResponse<MMRV3Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrV3ByIdWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String) : ApiResponse<MMRV3Response?> {
        val localVariableConfig = getMmrV3ByIdRequestConfig(affinity = affinity, platform = platform, puuid = puuid)

        return request<Unit, MMRV3Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrV3ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @return RequestConfig
     */
    fun getMmrV3ByIdRequestConfig(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v3/by-puuid/mmr/{affinity}/{platform}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v3/mmr/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return MMRV3Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMmrV3ByName(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String) : MMRV3Response {
        val localVarResponse = getMmrV3ByNameWithHttpInfo(affinity = affinity, platform = platform, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MMRV3Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v3/mmr/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return ApiResponse<MMRV3Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMmrV3ByNameWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String) : ApiResponse<MMRV3Response?> {
        val localVariableConfig = getMmrV3ByNameRequestConfig(affinity = affinity, platform = platform, name = name, tag = tag)

        return request<Unit, MMRV3Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMmrV3ByName
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @return RequestConfig
     */
    fun getMmrV3ByNameRequestConfig(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v3/mmr/{affinity}/{platform}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/leaderboard/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param season Season ID (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun leaderboardV1(affinity: kotlin.String, season: kotlin.String? = null, name: kotlin.String? = null, tag: kotlin.String? = null) : kotlin.Any {
        val localVarResponse = leaderboardV1WithHttpInfo(affinity = affinity, season = season, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/leaderboard/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param season Season ID (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun leaderboardV1WithHttpInfo(affinity: kotlin.String, season: kotlin.String?, name: kotlin.String?, tag: kotlin.String?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = leaderboardV1RequestConfig(affinity = affinity, season = season, name = name, tag = tag)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation leaderboardV1
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param season Season ID (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @return RequestConfig
     */
    fun leaderboardV1RequestConfig(affinity: kotlin.String, season: kotlin.String?, name: kotlin.String?, tag: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (season != null) {
                    put("season", listOf(season.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/leaderboard/{affinity}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/leaderboard/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param season Season ID (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @param puuid Player UUID to search for (optional) (optional)
     * @return LeaderboardV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun leaderboardV2(affinity: kotlin.String, season: kotlin.String? = null, name: kotlin.String? = null, tag: kotlin.String? = null, puuid: kotlin.String? = null) : LeaderboardV2Response {
        val localVarResponse = leaderboardV2WithHttpInfo(affinity = affinity, season = season, name = name, tag = tag, puuid = puuid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LeaderboardV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/leaderboard/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param season Season ID (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @param puuid Player UUID to search for (optional) (optional)
     * @return ApiResponse<LeaderboardV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun leaderboardV2WithHttpInfo(affinity: kotlin.String, season: kotlin.String?, name: kotlin.String?, tag: kotlin.String?, puuid: kotlin.String?) : ApiResponse<LeaderboardV2Response?> {
        val localVariableConfig = leaderboardV2RequestConfig(affinity = affinity, season = season, name = name, tag = tag, puuid = puuid)

        return request<Unit, LeaderboardV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation leaderboardV2
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param season Season ID (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @param puuid Player UUID to search for (optional) (optional)
     * @return RequestConfig
     */
    fun leaderboardV2RequestConfig(affinity: kotlin.String, season: kotlin.String?, name: kotlin.String?, tag: kotlin.String?, puuid: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (season != null) {
                    put("season", listOf(season.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (puuid != null) {
                    put("puuid", listOf(puuid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/leaderboard/{affinity}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v3/leaderboard/{affinity}/{platform}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param season Season ID (optional) (optional)
     * @param size Number of results per page (optional) (optional)
     * @param page Page number (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @return LeaderboardV3Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun leaderboardV3(affinity: kotlin.String, platform: kotlin.String, season: kotlin.String? = null, size: kotlin.Int? = null, page: kotlin.Int? = null, name: kotlin.String? = null, tag: kotlin.String? = null) : LeaderboardV3Response {
        val localVarResponse = leaderboardV3WithHttpInfo(affinity = affinity, platform = platform, season = season, size = size, page = page, name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LeaderboardV3Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v3/leaderboard/{affinity}/{platform}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param season Season ID (optional) (optional)
     * @param size Number of results per page (optional) (optional)
     * @param page Page number (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @return ApiResponse<LeaderboardV3Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun leaderboardV3WithHttpInfo(affinity: kotlin.String, platform: kotlin.String, season: kotlin.String?, size: kotlin.Int?, page: kotlin.Int?, name: kotlin.String?, tag: kotlin.String?) : ApiResponse<LeaderboardV3Response?> {
        val localVariableConfig = leaderboardV3RequestConfig(affinity = affinity, platform = platform, season = season, size = size, page = page, name = name, tag = tag)

        return request<Unit, LeaderboardV3Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation leaderboardV3
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param season Season ID (optional) (optional)
     * @param size Number of results per page (optional) (optional)
     * @param page Page number (optional) (optional)
     * @param name Player name to search for (optional) (optional)
     * @param tag Player tag to search for (optional) (optional)
     * @return RequestConfig
     */
    fun leaderboardV3RequestConfig(affinity: kotlin.String, platform: kotlin.String, season: kotlin.String?, size: kotlin.Int?, page: kotlin.Int?, name: kotlin.String?, tag: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (season != null) {
                    put("season", listOf(season.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v3/leaderboard/{affinity}/{platform}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/match/{match_id}
     * 
     * 
     * @param matchId Match UUID
     * @return MatchesV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun matchV2(matchId: kotlin.String) : MatchesV2Response {
        val localVarResponse = matchV2WithHttpInfo(matchId = matchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchesV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/match/{match_id}
     * 
     * 
     * @param matchId Match UUID
     * @return ApiResponse<MatchesV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun matchV2WithHttpInfo(matchId: kotlin.String) : ApiResponse<MatchesV2Response?> {
        val localVariableConfig = matchV2RequestConfig(matchId = matchId)

        return request<Unit, MatchesV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation matchV2
     *
     * @param matchId Match UUID
     * @return RequestConfig
     */
    fun matchV2RequestConfig(matchId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/match/{match_id}".replace("{"+"match_id"+"}", encodeURIComponent(matchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v4/match/{affinity}/{match_id}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param matchId Match UUID
     * @return MatchesV4Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun matchV4(affinity: kotlin.String, matchId: kotlin.String) : MatchesV4Response {
        val localVarResponse = matchV4WithHttpInfo(affinity = affinity, matchId = matchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchesV4Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v4/match/{affinity}/{match_id}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param matchId Match UUID
     * @return ApiResponse<MatchesV4Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun matchV4WithHttpInfo(affinity: kotlin.String, matchId: kotlin.String) : ApiResponse<MatchesV4Response?> {
        val localVariableConfig = matchV4RequestConfig(affinity = affinity, matchId = matchId)

        return request<Unit, MatchesV4Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation matchV4
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param matchId Match UUID
     * @return RequestConfig
     */
    fun matchV4RequestConfig(affinity: kotlin.String, matchId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v4/match/{affinity}/{match_id}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"match_id"+"}", encodeURIComponent(matchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/premier/{id}
     * 
     * 
     * @param id Team UUID
     * @return PremierTeamV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun premierById(id: kotlin.String) : PremierTeamV1Response {
        val localVarResponse = premierByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PremierTeamV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/premier/{id}
     * 
     * 
     * @param id Team UUID
     * @return ApiResponse<PremierTeamV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun premierByIdWithHttpInfo(id: kotlin.String) : ApiResponse<PremierTeamV1Response?> {
        val localVariableConfig = premierByIdRequestConfig(id = id)

        return request<Unit, PremierTeamV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation premierById
     *
     * @param id Team UUID
     * @return RequestConfig
     */
    fun premierByIdRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/premier/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/premier/{id}/history
     * 
     * 
     * @param id Team UUID
     * @return PremierTeamV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun premierByIdHistory(id: kotlin.String) : PremierTeamV1Response {
        val localVarResponse = premierByIdHistoryWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PremierTeamV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/premier/{id}/history
     * 
     * 
     * @param id Team UUID
     * @return ApiResponse<PremierTeamV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun premierByIdHistoryWithHttpInfo(id: kotlin.String) : ApiResponse<PremierTeamV1Response?> {
        val localVariableConfig = premierByIdHistoryRequestConfig(id = id)

        return request<Unit, PremierTeamV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation premierByIdHistory
     *
     * @param id Team UUID
     * @return RequestConfig
     */
    fun premierByIdHistoryRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/premier/{id}/history".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/premier/{name}/{tag}
     * 
     * 
     * @param name Team name
     * @param tag Team tag
     * @return PremierTeamV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun premierByName(name: kotlin.String, tag: kotlin.String) : PremierTeamV1Response {
        val localVarResponse = premierByNameWithHttpInfo(name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PremierTeamV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/premier/{name}/{tag}
     * 
     * 
     * @param name Team name
     * @param tag Team tag
     * @return ApiResponse<PremierTeamV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun premierByNameWithHttpInfo(name: kotlin.String, tag: kotlin.String) : ApiResponse<PremierTeamV1Response?> {
        val localVariableConfig = premierByNameRequestConfig(name = name, tag = tag)

        return request<Unit, PremierTeamV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation premierByName
     *
     * @param name Team name
     * @param tag Team tag
     * @return RequestConfig
     */
    fun premierByNameRequestConfig(name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/premier/{name}/{tag}".replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/premier/{name}/{tag}/history
     * 
     * 
     * @param name Team name
     * @param tag Team tag
     * @return PremierTeamHistoryV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun premierByNameHistory(name: kotlin.String, tag: kotlin.String) : PremierTeamHistoryV1Response {
        val localVarResponse = premierByNameHistoryWithHttpInfo(name = name, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PremierTeamHistoryV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/premier/{name}/{tag}/history
     * 
     * 
     * @param name Team name
     * @param tag Team tag
     * @return ApiResponse<PremierTeamHistoryV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun premierByNameHistoryWithHttpInfo(name: kotlin.String, tag: kotlin.String) : ApiResponse<PremierTeamHistoryV1Response?> {
        val localVariableConfig = premierByNameHistoryRequestConfig(name = name, tag = tag)

        return request<Unit, PremierTeamHistoryV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation premierByNameHistory
     *
     * @param name Team name
     * @param tag Team tag
     * @return RequestConfig
     */
    fun premierByNameHistoryRequestConfig(name: kotlin.String, tag: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/premier/{name}/{tag}/history".replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/premier/leaderboard/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param conference Conference filter (optional) (optional)
     * @param division Division filter (optional) (optional)
     * @return PremierSearchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun premierLeaderboard(affinity: kotlin.String, conference: kotlin.String? = null, division: kotlin.String? = null) : PremierSearchResponse {
        val localVarResponse = premierLeaderboardWithHttpInfo(affinity = affinity, conference = conference, division = division)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PremierSearchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/premier/leaderboard/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param conference Conference filter (optional) (optional)
     * @param division Division filter (optional) (optional)
     * @return ApiResponse<PremierSearchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun premierLeaderboardWithHttpInfo(affinity: kotlin.String, conference: kotlin.String?, division: kotlin.String?) : ApiResponse<PremierSearchResponse?> {
        val localVariableConfig = premierLeaderboardRequestConfig(affinity = affinity, conference = conference, division = division)

        return request<Unit, PremierSearchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation premierLeaderboard
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param conference Conference filter (optional) (optional)
     * @param division Division filter (optional) (optional)
     * @return RequestConfig
     */
    fun premierLeaderboardRequestConfig(affinity: kotlin.String, conference: kotlin.String?, division: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (conference != null) {
                    put("conference", listOf(conference.toString()))
                }
                if (division != null) {
                    put("division", listOf(division.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/premier/leaderboard/{affinity}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/premier/search
     * 
     * 
     * @param name Team name to search for (optional) (optional)
     * @param tag Team tag to search for (optional) (optional)
     * @param id Team UUID to search for (optional) (optional)
     * @return PremierSearchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun premierSearch(name: kotlin.String? = null, tag: kotlin.String? = null, id: kotlin.String? = null) : PremierSearchResponse {
        val localVarResponse = premierSearchWithHttpInfo(name = name, tag = tag, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PremierSearchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/premier/search
     * 
     * 
     * @param name Team name to search for (optional) (optional)
     * @param tag Team tag to search for (optional) (optional)
     * @param id Team UUID to search for (optional) (optional)
     * @return ApiResponse<PremierSearchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun premierSearchWithHttpInfo(name: kotlin.String?, tag: kotlin.String?, id: kotlin.String?) : ApiResponse<PremierSearchResponse?> {
        val localVariableConfig = premierSearchRequestConfig(name = name, tag = tag, id = id)

        return request<Unit, PremierSearchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation premierSearch
     *
     * @param name Team name to search for (optional) (optional)
     * @param tag Team tag to search for (optional) (optional)
     * @param id Team UUID to search for (optional) (optional)
     * @return RequestConfig
     */
    fun premierSearchRequestConfig(name: kotlin.String?, tag: kotlin.String?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/premier/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/queue-status/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return QueueStatusV1
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun queueStatus(affinity: kotlin.String) : QueueStatusV1 {
        val localVarResponse = queueStatusWithHttpInfo(affinity = affinity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as QueueStatusV1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/queue-status/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return ApiResponse<QueueStatusV1?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun queueStatusWithHttpInfo(affinity: kotlin.String) : ApiResponse<QueueStatusV1?> {
        val localVariableConfig = queueStatusRequestConfig(affinity = affinity)

        return request<Unit, QueueStatusV1>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation queueStatus
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return RequestConfig
     */
    fun queueStatusRequestConfig(affinity: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/queue-status/{affinity}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /valorant/v1/raw
     * 
     * 
     * @param rawV1Payload 
     * @return RawV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun raw(rawV1Payload: RawV1Payload) : RawV1Response {
        val localVarResponse = rawWithHttpInfo(rawV1Payload = rawV1Payload)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RawV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /valorant/v1/raw
     * 
     * 
     * @param rawV1Payload 
     * @return ApiResponse<RawV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rawWithHttpInfo(rawV1Payload: RawV1Payload) : ApiResponse<RawV1Response?> {
        val localVariableConfig = rawRequestConfig(rawV1Payload = rawV1Payload)

        return request<RawV1Payload, RawV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation raw
     *
     * @param rawV1Payload 
     * @return RequestConfig
     */
    fun rawRequestConfig(rawV1Payload: RawV1Payload) : RequestConfig<RawV1Payload> {
        val localVariableBody = rawV1Payload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/valorant/v1/raw",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/status/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return StatusV1
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun status(affinity: kotlin.String) : StatusV1 {
        val localVarResponse = statusWithHttpInfo(affinity = affinity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StatusV1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/status/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return ApiResponse<StatusV1?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun statusWithHttpInfo(affinity: kotlin.String) : ApiResponse<StatusV1?> {
        val localVariableConfig = statusRequestConfig(affinity = affinity)

        return request<Unit, StatusV1>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation status
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return RequestConfig
     */
    fun statusRequestConfig(affinity: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/status/{affinity}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/{version}/store-featured
     * 
     * 
     * @param version API version (v1, v2)
     * @return StoreFeaturedV1
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storeFeatured(version: kotlin.String) : StoreFeaturedV1 {
        val localVarResponse = storeFeaturedWithHttpInfo(version = version)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoreFeaturedV1
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/{version}/store-featured
     * 
     * 
     * @param version API version (v1, v2)
     * @return ApiResponse<StoreFeaturedV1?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storeFeaturedWithHttpInfo(version: kotlin.String) : ApiResponse<StoreFeaturedV1?> {
        val localVariableConfig = storeFeaturedRequestConfig(version = version)

        return request<Unit, StoreFeaturedV1>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storeFeatured
     *
     * @param version API version (v1, v2)
     * @return RequestConfig
     */
    fun storeFeaturedRequestConfig(version: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/{version}/store-featured".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/{version}/store-offers
     * 
     * 
     * @param version API version (v1, v2)
     * @return StoreOffersV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storeOffers(version: kotlin.String) : StoreOffersV1Response {
        val localVarResponse = storeOffersWithHttpInfo(version = version)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoreOffersV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/{version}/store-offers
     * 
     * 
     * @param version API version (v1, v2)
     * @return ApiResponse<StoreOffersV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storeOffersWithHttpInfo(version: kotlin.String) : ApiResponse<StoreOffersV1Response?> {
        val localVariableConfig = storeOffersRequestConfig(version = version)

        return request<Unit, StoreOffersV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storeOffers
     *
     * @param version API version (v1, v2)
     * @return RequestConfig
     */
    fun storeOffersRequestConfig(version: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/{version}/store-offers".replace("{"+"version"+"}", encodeURIComponent(version.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/stored-matches/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return StoredMatchesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storedMatches(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: kotlin.String? = null, map: kotlin.String? = null, size: kotlin.Int? = null) : StoredMatchesResponse {
        val localVarResponse = storedMatchesWithHttpInfo(affinity = affinity, name = name, tag = tag, mode = mode, map = map, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoredMatchesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/stored-matches/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<StoredMatchesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storedMatchesWithHttpInfo(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?) : ApiResponse<StoredMatchesResponse?> {
        val localVariableConfig = storedMatchesRequestConfig(affinity = affinity, name = name, tag = tag, mode = mode, map = map, size = size)

        return request<Unit, StoredMatchesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storedMatches
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun storedMatchesRequestConfig(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (map != null) {
                    put("map", listOf(map.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/stored-matches/{affinity}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/by-puuid/stored-matches/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return StoredMatchesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storedMatchesById(affinity: kotlin.String, puuid: kotlin.String, mode: kotlin.String? = null, map: kotlin.String? = null, size: kotlin.Int? = null) : StoredMatchesResponse {
        val localVarResponse = storedMatchesByIdWithHttpInfo(affinity = affinity, puuid = puuid, mode = mode, map = map, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoredMatchesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/by-puuid/stored-matches/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<StoredMatchesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storedMatchesByIdWithHttpInfo(affinity: kotlin.String, puuid: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?) : ApiResponse<StoredMatchesResponse?> {
        val localVariableConfig = storedMatchesByIdRequestConfig(affinity = affinity, puuid = puuid, mode = mode, map = map, size = size)

        return request<Unit, StoredMatchesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storedMatchesById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param mode Game mode filter (optional) (optional)
     * @param map Map filter (optional) (optional)
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun storedMatchesByIdRequestConfig(affinity: kotlin.String, puuid: kotlin.String, mode: kotlin.String?, map: kotlin.String?, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (mode != null) {
                    put("mode", listOf(mode.toString()))
                }
                if (map != null) {
                    put("map", listOf(map.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/by-puuid/stored-matches/{affinity}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/stored-mmr-history/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param size Number of results (optional) (optional)
     * @return StoredMMRResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storedMmrHistory(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, size: kotlin.Int? = null) : StoredMMRResponse {
        val localVarResponse = storedMmrHistoryWithHttpInfo(affinity = affinity, name = name, tag = tag, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoredMMRResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/stored-mmr-history/{affinity}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<StoredMMRResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storedMmrHistoryWithHttpInfo(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, size: kotlin.Int?) : ApiResponse<StoredMMRResponse?> {
        val localVariableConfig = storedMmrHistoryRequestConfig(affinity = affinity, name = name, tag = tag, size = size)

        return request<Unit, StoredMMRResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storedMmrHistory
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun storedMmrHistoryRequestConfig(affinity: kotlin.String, name: kotlin.String, tag: kotlin.String, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/stored-mmr-history/{affinity}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/by-puuid/stored-mmr-history/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param size Number of results (optional) (optional)
     * @return StoredMMRResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storedMmrHistoryById(affinity: kotlin.String, puuid: kotlin.String, size: kotlin.Int? = null) : StoredMMRResponse {
        val localVarResponse = storedMmrHistoryByIdWithHttpInfo(affinity = affinity, puuid = puuid, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoredMMRResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/by-puuid/stored-mmr-history/{affinity}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<StoredMMRResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storedMmrHistoryByIdWithHttpInfo(affinity: kotlin.String, puuid: kotlin.String, size: kotlin.Int?) : ApiResponse<StoredMMRResponse?> {
        val localVariableConfig = storedMmrHistoryByIdRequestConfig(affinity = affinity, puuid = puuid, size = size)

        return request<Unit, StoredMMRResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storedMmrHistoryById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param puuid Player UUID
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun storedMmrHistoryByIdRequestConfig(affinity: kotlin.String, puuid: kotlin.String, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/by-puuid/stored-mmr-history/{affinity}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/stored-mmr-history/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param size Number of results (optional) (optional)
     * @return StoredMMRV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storedMmrHistoryV2(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String, size: kotlin.Int? = null) : StoredMMRV2Response {
        val localVarResponse = storedMmrHistoryV2WithHttpInfo(affinity = affinity, platform = platform, name = name, tag = tag, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoredMMRV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/stored-mmr-history/{affinity}/{platform}/{name}/{tag}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<StoredMMRV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storedMmrHistoryV2WithHttpInfo(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String, size: kotlin.Int?) : ApiResponse<StoredMMRV2Response?> {
        val localVariableConfig = storedMmrHistoryV2RequestConfig(affinity = affinity, platform = platform, name = name, tag = tag, size = size)

        return request<Unit, StoredMMRV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storedMmrHistoryV2
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param name Riot ID name
     * @param tag Riot ID tag
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun storedMmrHistoryV2RequestConfig(affinity: kotlin.String, platform: kotlin.String, name: kotlin.String, tag: kotlin.String, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/stored-mmr-history/{affinity}/{platform}/{name}/{tag}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"name"+"}", encodeURIComponent(name.toString())).replace("{"+"tag"+"}", encodeURIComponent(tag.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v2/by-puuid/stored-mmr-history/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @param size Number of results (optional) (optional)
     * @return StoredMMRV2Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun storedMmrHistoryV2ById(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String, size: kotlin.Int? = null) : StoredMMRV2Response {
        val localVarResponse = storedMmrHistoryV2ByIdWithHttpInfo(affinity = affinity, platform = platform, puuid = puuid, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StoredMMRV2Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v2/by-puuid/stored-mmr-history/{affinity}/{platform}/{puuid}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @param size Number of results (optional) (optional)
     * @return ApiResponse<StoredMMRV2Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun storedMmrHistoryV2ByIdWithHttpInfo(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String, size: kotlin.Int?) : ApiResponse<StoredMMRV2Response?> {
        val localVariableConfig = storedMmrHistoryV2ByIdRequestConfig(affinity = affinity, platform = platform, puuid = puuid, size = size)

        return request<Unit, StoredMMRV2Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storedMmrHistoryV2ById
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @param platform Platform (pc, console)
     * @param puuid Player UUID
     * @param size Number of results (optional) (optional)
     * @return RequestConfig
     */
    fun storedMmrHistoryV2ByIdRequestConfig(affinity: kotlin.String, platform: kotlin.String, puuid: kotlin.String, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v2/by-puuid/stored-mmr-history/{affinity}/{platform}/{puuid}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())).replace("{"+"platform"+"}", encodeURIComponent(platform.toString())).replace("{"+"puuid"+"}", encodeURIComponent(puuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/version/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return VersionV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun version(affinity: kotlin.String) : VersionV1Response {
        val localVarResponse = versionWithHttpInfo(affinity = affinity)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/version/{affinity}
     * 
     * 
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return ApiResponse<VersionV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun versionWithHttpInfo(affinity: kotlin.String) : ApiResponse<VersionV1Response?> {
        val localVariableConfig = versionRequestConfig(affinity = affinity)

        return request<Unit, VersionV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation version
     *
     * @param affinity Region/affinity (e.g., na, eu, ap, kr)
     * @return RequestConfig
     */
    fun versionRequestConfig(affinity: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/version/{affinity}".replace("{"+"affinity"+"}", encodeURIComponent(affinity.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/website/{country_code}
     * 
     * 
     * @param countryCode Country code (e.g., en-us, de-de)
     * @param category Category filter (optional) (optional)
     * @return WebsiteV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun website(countryCode: kotlin.String, category: kotlin.String? = null) : WebsiteV1Response {
        val localVarResponse = websiteWithHttpInfo(countryCode = countryCode, category = category)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebsiteV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/website/{country_code}
     * 
     * 
     * @param countryCode Country code (e.g., en-us, de-de)
     * @param category Category filter (optional) (optional)
     * @return ApiResponse<WebsiteV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun websiteWithHttpInfo(countryCode: kotlin.String, category: kotlin.String?) : ApiResponse<WebsiteV1Response?> {
        val localVariableConfig = websiteRequestConfig(countryCode = countryCode, category = category)

        return request<Unit, WebsiteV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation website
     *
     * @param countryCode Country code (e.g., en-us, de-de)
     * @param category Category filter (optional) (optional)
     * @return RequestConfig
     */
    fun websiteRequestConfig(countryCode: kotlin.String, category: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (category != null) {
                    put("category", listOf(category.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/website/{country_code}".replace("{"+"country_code"+"}", encodeURIComponent(countryCode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /valorant/v1/website/{country_code}/{db_id}
     * 
     * 
     * @param dbId Database ID of the website entry
     * @param countryCode Country code (e.g., en-us, de-de)
     * @return WebsiteByIdV1Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun websiteById(dbId: kotlin.String, countryCode: kotlin.String) : WebsiteByIdV1Response {
        val localVarResponse = websiteByIdWithHttpInfo(dbId = dbId, countryCode = countryCode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WebsiteByIdV1Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /valorant/v1/website/{country_code}/{db_id}
     * 
     * 
     * @param dbId Database ID of the website entry
     * @param countryCode Country code (e.g., en-us, de-de)
     * @return ApiResponse<WebsiteByIdV1Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun websiteByIdWithHttpInfo(dbId: kotlin.String, countryCode: kotlin.String) : ApiResponse<WebsiteByIdV1Response?> {
        val localVariableConfig = websiteByIdRequestConfig(dbId = dbId, countryCode = countryCode)

        return request<Unit, WebsiteByIdV1Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation websiteById
     *
     * @param dbId Database ID of the website entry
     * @param countryCode Country code (e.g., en-us, de-de)
     * @return RequestConfig
     */
    fun websiteByIdRequestConfig(dbId: kotlin.String, countryCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/valorant/v1/website/{country_code}/{db_id}".replace("{"+"db_id"+"}", encodeURIComponent(dbId.toString())).replace("{"+"country_code"+"}", encodeURIComponent(countryCode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
