/* tslint:disable */
/* eslint-disable */
/**
 * HenrikDev API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface APIError {
    'code': number;
    'details'?: any;
    'message': string;
    'status': number;
}
export interface AccountV1Data {
    'account_level': number;
    'card': AccountV1DataCard;
    'last_update': string;
    'last_update_raw': number;
    'name': string;
    'puuid': string;
    'region': string;
    'tag': string;
}
export interface AccountV1DataCard {
    'id': string;
    'large': string;
    'small': string;
    'wide': string;
}
export interface AccountV1Response {
    'data': AccountV1Data;
    'status': number;
}
export interface AccountV2Data {
    'account_level': number;
    'card': string;
    'name': string;
    'platforms': Array<string>;
    'puuid': string;
    'region': string;
    'tag': string;
    'title': string;
    'updated_at': string;
}
export interface AccountV2Response {
    'data': AccountV2Data;
    'status': number;
}
export interface AgentIdNameCombo {
    'id': string;
    'name': string;
}
export interface Bundle {
    'CurrencyID': string;
    'DataAssetID': string;
    'DurationRemainingInSeconds': number;
    'ID': string;
    'Items': Array<BundleItem>;
    'TotalDiscountPercent': number;
    'WholesaleOnly': boolean;
}
export interface BundleItem {
    'BasePrice': number;
    'CurrencyID': string;
    'DiscountPercent': number;
    'DiscountedPrice': number;
    'IsPromoItem': boolean;
    'Item': Item;
}
export interface ContentItem {
    'assetName': string;
    'id'?: string | null;
    'localizedNames'?: { [key: string]: string; };
    'name': string;
}
export interface ContentV1 {
    'acts': Array<ContentItem>;
    'ceremonies': Array<ContentItem>;
    'characters': Array<ContentItem>;
    'charmLevels': Array<ContentItem>;
    'charms': Array<ContentItem>;
    'chromas': Array<ContentItem>;
    'equips': Array<ContentItem>;
    'gameModes': Array<ContentItem>;
    'maps': Array<ContentItem>;
    'playerCards': Array<ContentItem>;
    'playerTitles': Array<ContentItem>;
    'skinLevels': Array<ContentItem>;
    'skins': Array<ContentItem>;
    'sprayLevels': Array<ContentItem>;
    'sprays': Array<ContentItem>;
    'version': string;
}
export interface ContentV1Response {
    'data': ContentV1;
    'status': number;
}
export interface EsportsV1Data {
    'date': string;
    'league': EsportsV1DataLeague;
    'match': EsportsV1DataMatch;
    'state': string;
    'tournament': EsportsV1DataTournament;
    'type': string;
    'vod'?: string | null;
}
export interface EsportsV1DataLeague {
    'icon': string;
    'identifier': string;
    'name': string;
    'region': string;
}
export interface EsportsV1DataMatch {
    'game_type': EsportsV1DataMatchGameType;
    'id'?: string | null;
    'teams': Array<EsportsV1DataMatchTeams>;
}
export interface EsportsV1DataMatchGameType {
    'count'?: number | null;
    'type'?: string | null;
}
export interface EsportsV1DataMatchTeams {
    'code': string;
    'game_wins': number;
    'has_won': boolean;
    'icon': string;
    'name': string;
    'record': EsportsV1DataMatchTeamsRecord;
}
export interface EsportsV1DataMatchTeamsRecord {
    'losses': number;
    'wins': number;
}
export interface EsportsV1DataTournament {
    'name': string;
    'season': string;
}
export interface EsportsV1Response {
    'data': Array<EsportsV1Data>;
    'status': number;
}
export interface FeaturedBundle {
    'Bundle': Bundle;
    'BundleRemainingDurationInSeconds': number;
    'Bundles': Array<Bundle>;
}
export interface Item {
    'Amount': number;
    'ItemID': string;
    'ItemTypeID': string;
}
export interface LeaderboardPVPPlayer {
    'IsAnonymized': boolean;
    'IsBanned': boolean;
    'PlayerCardID': string;
    'TitleID': string;
    'competitiveTier': number;
    'gameName': string;
    'leaderboardRank': number;
    'numberOfWins': number;
    'puuid'?: string | null;
    'rankedRating': number;
    'tagLine': string;
}
export interface LeaderboardV2Response {
    'immortal_1_threshold': number;
    'immortal_2_threshold': number;
    'immortal_3_threshold': number;
    'last_update': number;
    'next_update': number;
    'players': Array<LeaderboardPVPPlayer>;
    'radiant_threshold': number;
    'total_players': number;
}
export interface LeaderboardV3Data {
    'players': Array<LeaderboardV3DataPlayer>;
    'thresholds': Array<LeaderboardV3DataThreshold>;
    'updated_at': string;
}
export interface LeaderboardV3DataPlayer {
    'card': string;
    'is_anonymized': boolean;
    'is_banned': boolean;
    'leaderboard_rank': number;
    'name': string;
    'puuid'?: string | null;
    'rr': number;
    'tag': string;
    'tier': number;
    'title': string;
    'updated_at': string;
    'wins': number;
}
export interface LeaderboardV3DataThreshold {
    'start_index': number;
    'threshold': number;
    'tier': LeaderboardV3DataThresholdTier;
}
export interface LeaderboardV3DataThresholdTier {
    'id': number;
    'name': string;
}
export interface LeaderboardV3Response {
    'data': LeaderboardV3Data;
    'results': Pagination;
    'status': number;
}
export interface MMRDataImages {
    'large': string;
    'small': string;
    'triangle_down': string;
    'triangle_up': string;
}
export interface MMRHistoryV1Data {
    'currenttier': number;
    'currenttierpatched': string;
    'date': string;
    'date_raw': number;
    'elo': number;
    'images': MMRDataImages;
    'map': MMRHistoryV1DataMap;
    'match_id': string;
    'mmr_change_to_last_game': number;
    'ranking_in_tier': number;
    'season_id': string;
}
export interface MMRHistoryV1DataMap {
    'id': string;
    'name': string;
}
export interface MMRHistoryV1Response {
    'data': Array<MMRHistoryV1Data>;
    'name': string;
    'status': number;
    'tag': string;
}
export interface MMRHistoryV2Data {
    'account': MMRV3Account;
    'history': Array<MMRHistoryV2History>;
}
export interface MMRHistoryV2History {
    'date': string;
    'elo': number;
    'last_change': number;
    'map': MapIdNameCombo;
    'match_id': string;
    'refunded_rr': number;
    'rr': number;
    'season': SeasonIdShortCombo;
    'tier': TierIdNameCombo;
    'was_derank_protected': boolean;
}
export interface MMRHistoryV2Response {
    'data': MMRHistoryV2Data;
    'status': number;
}
export interface MMRV1Data {
    'currenttier': number;
    'currenttierpatched': string;
    'elo': number;
    'images': MMRDataImages;
    'mmr_change_to_last_game': number;
    'name': string;
    'old': boolean;
    'ranking_in_tier': number;
    'tag': string;
}
export interface MMRV1Response {
    'data': MMRV1Data;
    'status': number;
}
export interface MMRV2CurrentData {
    'currenttier': number;
    'currenttierpatched': string;
    'elo': number;
    'games_needed_for_rating': number;
    'images': MMRDataImages;
    'mmr_change_to_last_game': number;
    'old': boolean;
    'ranking_in_tier': number;
}
export interface MMRV2Data {
    'by_season': any;
    'current_data': MMRV2CurrentData;
    'highest_rank': MMRV2HighestRank;
    'name': string;
    'puuid': string;
    'tag': string;
}
export interface MMRV2HighestRank {
    'old': boolean;
    'patched_tier': string;
    'season': string;
    'tier': number;
}
export interface MMRV2Response {
    'data': MMRV2Data;
    'status': number;
}
export interface MMRV3Account {
    'name': string;
    'puuid': string;
    'tag': string;
}
export interface MMRV3Current {
    'elo': number;
    'games_needed_for_rating': number;
    'last_change': number;
    'leaderboard_placement'?: MMRV3LeaderboardPlacement | null;
    'rank_protection_shields': number;
    'rr': number;
    'tier': TierIdNameCombo;
}
export interface MMRV3Data {
    'account': MMRV3Account;
    'current': MMRV3Current;
    'peak'?: MMRV3Peak | null;
    'seasonal': Array<MMRV3Seasonal>;
}
export interface MMRV3LeaderboardPlacement {
    'rank': number;
    'updated_at': string;
}
export interface MMRV3Peak {
    'ranking_schema': string;
    'rr': number;
    'season': SeasonIdShortCombo;
    'tier': TierIdNameCombo;
}
export interface MMRV3Response {
    'data': MMRV3Data;
    'status': number;
}
export interface MMRV3Seasonal {
    'act_wins': Array<TierIdNameCombo>;
    'end_rr': number;
    'end_tier': TierIdNameCombo;
    'games': number;
    'leaderboard_placement'?: MMRV3LeaderboardPlacement | null;
    'ranking_schema': string;
    'season': SeasonIdShortCombo;
    'wins': number;
}
export interface MapIdNameCombo {
    'id': string;
    'name': string;
}

export const MatchMode = {
    Competitive: 'Competitive',
    Unrated: 'Unrated',
    Custom: 'Custom',
    Practice: 'Practice',
    Unknown: 'Unknown'
} as const;

export type MatchMode = typeof MatchMode[keyof typeof MatchMode];


export interface MatchesV2Data {
    'coaches': Array<MatchesV2DataCoach>;
    'kills': Array<MatchesV2DataKill>;
    'metadata': MatchesV2DataMetadata;
    'observers': Array<MatchesV2DataObserver>;
    'players': MatchesV2DataPlayers;
    'rounds': Array<MatchesV2DataRound>;
    'teams': MatchesV2DataTeams;
}
export interface MatchesV2DataCoach {
    'puuid': string;
    'team': string;
}
export interface MatchesV2DataKill {
    'assistants': Array<MatchesV2DataRoundPlayerStatsKillEventsAssistants>;
    'damage_weapon_assets': MatchesV2DataRoundPlayerStatsKillEventsAssets;
    'damage_weapon_id': string;
    'damage_weapon_name'?: string | null;
    'kill_time_in_match': number;
    'kill_time_in_round': number;
    'killer_display_name': string;
    'killer_puuid': string;
    'killer_team': string;
    'player_locations_on_kill': Array<MatchesV2DataRoundPlayerLocationsOnEvent>;
    'round': number;
    'secondary_fire_mode': boolean;
    'victim_death_location': MatchesV2DataRoundEventLocation;
    'victim_display_name': string;
    'victim_puuid': string;
    'victim_team': string;
}
export interface MatchesV2DataMetadata {
    'cluster'?: string | null;
    'game_length': number;
    'game_start': number;
    'game_start_patched': string;
    'game_version': string;
    'map'?: string | null;
    'matchid': string;
    'mode'?: string | null;
    'mode_id': string;
    'platform': string;
    'premier_info': MatchesV2DataMetadataPremierInfo;
    'queue'?: string | null;
    'region'?: string | null;
    'rounds_played': number;
    'season_id': string;
}
export interface MatchesV2DataMetadataPremierInfo {
    'matchup_id'?: string | null;
    'tournament_id'?: string | null;
}
export interface MatchesV2DataObserver {
    'level': number;
    'name': string;
    'party_id': string;
    'platform': MatchesV2DataPlatform;
    'player_card': string;
    'player_title': string;
    'puuid': string;
    'session_playtime': MatchesV2DataPlayerSessionPlaytime;
    'tag': string;
    'team': string;
}
export interface MatchesV2DataPlatform {
    'os': MatchesV2DataPlatformOs;
    'type': string;
}
export interface MatchesV2DataPlatformOs {
    'name': string;
    'version': string;
}
export interface MatchesV2DataPlayer {
    'ability_casts': MatchesV2DataPlayerAbilityCasts;
    'assets': MatchesV2DataPlayerAssets;
    'behavior': MatchesV2DataPlayerBehavior;
    'character'?: string | null;
    'currenttier': number;
    'currenttier_patched': string;
    'damage_made': number;
    'damage_received': number;
    'economy': MatchesV2DataPlayerEconomy;
    'level': number;
    'name': string;
    'party_id': string;
    'platform': MatchesV2DataPlatform;
    'player_card': string;
    'player_title': string;
    'puuid': string;
    'session_playtime': MatchesV2DataPlayerSessionPlaytime;
    'stats': MatchesV2DataPlayerStats;
    'tag': string;
    'team': string;
}
export interface MatchesV2DataPlayerAbilityCasts {
    'c_cast'?: number | null;
    'e_cast'?: number | null;
    'q_cast'?: number | null;
    'x_cast'?: number | null;
}
export interface MatchesV2DataPlayerAssets {
    'agent': MatchesV2DataPlayerAssetsAgent;
    'card': MatchesV2DataPlayerAssetsCard;
}
export interface MatchesV2DataPlayerAssetsAgent {
    'bust': string;
    'full': string;
    'killfeed': string;
    'small': string;
}
export interface MatchesV2DataPlayerAssetsCard {
    'large': string;
    'small': string;
    'wide': string;
}
export interface MatchesV2DataPlayerBehavior {
    'afk_rounds': number;
    'friendly_fire': MatchesV2DataPlayerBehaviorFriendlyFire;
    'rounds_in_spawn'?: number | null;
}
export interface MatchesV2DataPlayerBehaviorFriendlyFire {
    'incoming'?: number | null;
    'outgoing'?: number | null;
}
export interface MatchesV2DataPlayerEconomy {
    'loadout_value': MatchesV2DataPlayerEconomyValue;
    'spent': MatchesV2DataPlayerEconomyValue;
}
export interface MatchesV2DataPlayerEconomyValue {
    'average': number;
    'overall': number;
}
export interface MatchesV2DataPlayerSessionPlaytime {
    'milliseconds': number;
    'minutes': number;
    'seconds': number;
}
export interface MatchesV2DataPlayerStats {
    'assists': number;
    'bodyshots': number;
    'deaths': number;
    'headshots': number;
    'kills': number;
    'legshots': number;
    'score': number;
}
export interface MatchesV2DataPlayers {
    'all_players': Array<MatchesV2DataPlayer>;
    'blue': Array<MatchesV2DataPlayer>;
    'red': Array<MatchesV2DataPlayer>;
}
export interface MatchesV2DataRound {
    'bomb_defused': boolean;
    'bomb_planted': boolean;
    'defuse_events': MatchesV2DataRoundDefuseEvents;
    'end_type': string;
    'plant_events': MatchesV2DataRoundPlantEvents;
    'player_stats': Array<MatchesV2DataRoundPlayerStats>;
    'winning_team': string;
}
export interface MatchesV2DataRoundDefuseEvents {
    'defuse_location'?: MatchesV2DataRoundEventLocation | null;
    'defuse_time_in_round'?: number | null;
    'defused_by'?: MatchesV2DataRoundPlayer | null;
    'player_locations_on_defuse'?: Array<MatchesV2DataRoundPlayerLocationsOnEvent> | null;
}
export interface MatchesV2DataRoundEventLocation {
    'x': number;
    'y': number;
}
export interface MatchesV2DataRoundPlantEvents {
    'plant_location'?: MatchesV2DataRoundEventLocation | null;
    'plant_site'?: string | null;
    'plant_time_in_round'?: number | null;
    'planted_by'?: MatchesV2DataRoundPlayer | null;
    'player_locations_on_plant'?: Array<MatchesV2DataRoundPlayerLocationsOnEvent> | null;
}
export interface MatchesV2DataRoundPlayer {
    'display_name': string;
    'puuid': string;
    'team': string;
}
export interface MatchesV2DataRoundPlayerLocationsOnEvent {
    'location': MatchesV2DataRoundEventLocation;
    'player_display_name': string;
    'player_puuid': string;
    'player_team': string;
    'view_radians': number;
}
export interface MatchesV2DataRoundPlayerStats {
    'ability_casts': MatchesV2DataRoundPlayerStatsAbilityCasts;
    'bodyshots': number;
    'damage': number;
    'damage_events': Array<MatchesV2DataRoundPlayerStatsDamageEvents>;
    'economy': MatchesV2DataRoundPlayerStatsEconomy;
    'headshots': number;
    'kill_events': Array<MatchesV2DataRoundPlayerStatsKillEvents>;
    'kills': number;
    'legshots': number;
    'player_display_name': string;
    'player_puuid': string;
    'player_team': string;
    'score': number;
    'stayed_in_spawn': boolean;
    'was_afk': boolean;
    'was_penalized': boolean;
}
export interface MatchesV2DataRoundPlayerStatsAbilityCasts {
    'c_casts'?: number | null;
    'e_casts'?: number | null;
    'q_casts'?: number | null;
    'x_casts'?: number | null;
}
export interface MatchesV2DataRoundPlayerStatsDamageEvents {
    'bodyshots': number;
    'damage': number;
    'headshots': number;
    'legshots': number;
    'receiver_display_name': string;
    'receiver_puuid': string;
    'receiver_team': string;
}
export interface MatchesV2DataRoundPlayerStatsEconomy {
    'armor': MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor;
    'loadout_value': number;
    'remaining': number;
    'spent': number;
    'weapon': MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon;
}
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor {
    'assets': MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor;
    'id'?: string | null;
    'name'?: string | null;
}
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets {
    'display_icon'?: string | null;
    'killfeed_icon'?: string | null;
}
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor {
    'display_icon'?: string | null;
}
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon {
    'assets': MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets;
    'id'?: string | null;
    'name'?: string | null;
}
export interface MatchesV2DataRoundPlayerStatsKillEvents {
    'assistants': Array<MatchesV2DataRoundPlayerStatsKillEventsAssistants>;
    'damage_weapon_assets': MatchesV2DataRoundPlayerStatsKillEventsAssets;
    'damage_weapon_id': string;
    'damage_weapon_name'?: string | null;
    'kill_time_in_match': number;
    'kill_time_in_round': number;
    'killer_display_name': string;
    'killer_puuid': string;
    'killer_team': string;
    'player_locations_on_kill': Array<MatchesV2DataRoundPlayerLocationsOnEvent>;
    'secondary_fire_mode': boolean;
    'victim_death_location': MatchesV2DataRoundEventLocation;
    'victim_display_name': string;
    'victim_puuid': string;
    'victim_team': string;
}
export interface MatchesV2DataRoundPlayerStatsKillEventsAssets {
    'display_icon'?: string | null;
    'killfeed_icon'?: string | null;
}
export interface MatchesV2DataRoundPlayerStatsKillEventsAssistants {
    'assistant_display_name': string;
    'assistant_puuid': string;
    'assistant_team': string;
}
export interface MatchesV2DataTeam {
    'has_won'?: boolean | null;
    'roster'?: MatchesV2DataTeamRoster | null;
    'rounds_lost'?: number | null;
    'rounds_won'?: number | null;
}
export interface MatchesV2DataTeamRoster {
    'customization': MatchesV2DataTeamRosterCustomization;
    'id': string;
    'members': Array<string>;
    'name': string;
    'tag': string;
}
export interface MatchesV2DataTeamRosterCustomization {
    'icon': string;
    'image': string;
    'primary_color': string;
    'secondary_color': string;
    'tertiary_color': string;
}
export interface MatchesV2DataTeams {
    'blue': MatchesV2DataTeam;
    'red': MatchesV2DataTeam;
}
export interface MatchesV2Response {
    'data': MatchesV2Data;
    'status': number;
}
export interface MatchesV3ListResponse {
    'data': Array<MatchesV3ListResponseData>;
    'status': number;
}
export interface MatchesV3ListResponseData {
    'coaches': Array<MatchesV2DataCoach>;
    'is_available': boolean;
    'kills': Array<MatchesV2DataKill>;
    'metadata'?: MatchesV2DataMetadata | null;
    'observers': Array<MatchesV2DataObserver>;
    'players'?: MatchesV2DataPlayers | null;
    'rounds': Array<MatchesV2DataRound>;
    'teams'?: MatchesV2DataTeams | null;
}
export interface MatchesV4Data {
    'coaches': Array<MatchesV4DataCoach>;
    'kills': Array<MatchesV4DataKill>;
    'metadata': MatchesV4DataMetadata;
    'observers': Array<MatchesV4DataObserver>;
    'players': Array<MatchesV4DataPlayer>;
    'rounds': Array<MatchesV4DataRound>;
    'teams': Array<MatchesV4DataTeam>;
}
export interface MatchesV4DataCoach {
    'puuid': string;
    'team_id': string;
}
export interface MatchesV4DataKill {
    'assistants': Array<MatchesV4DataRoundPlayer>;
    'killer': MatchesV4DataRoundPlayer;
    'location': MatchesV4DataRoundLocation;
    'player_locations': Array<MatchesV4DataRoundPlayerLocations>;
    'round': number;
    'secondary_fire_mode': boolean;
    'time_in_match_in_ms': number;
    'time_in_round_in_ms': number;
    'victim': MatchesV4DataRoundPlayer;
    'weapon': MatchesV4DataRoundPlayerStatsEconomyWeapon;
}
export interface MatchesV4DataMetadata {
    'cluster'?: string | null;
    'game_length_in_ms': number;
    'game_version': string;
    'is_completed': boolean;
    'map': MapIdNameCombo;
    'match_id': string;
    'party_rr_penaltys': Array<MatchesV4DataMetadataPartyRRPenalty>;
    'platform': string;
    'premier'?: any;
    'queue': MatchesV4DataMetadataQueue;
    'region'?: string | null;
    'season': SeasonIdShortCombo;
    'started_at': string;
}
export interface MatchesV4DataMetadataPartyRRPenalty {
    'party_id': string;
    'penalty': number;
}
export interface MatchesV4DataMetadataQueue {
    'id': string;
    'mode_type'?: string | null;
    'name'?: string | null;
}
export interface MatchesV4DataObserver {
    'account_level': number;
    'card_id': string;
    'name': string;
    'party_id': string;
    'puuid': string;
    'session_playtime_in_ms': number;
    'tag': string;
    'title_id': string;
}
export interface MatchesV4DataPlayer {
    'ability_casts': MatchesV4DataPlayerAbilityCasts;
    'account_level': number;
    'agent': AgentIdNameCombo;
    'behavior': MatchesV4DataPlayerBehavior;
    'customization': MatchesV4DataPlayerCustomization;
    'economy': MatchesV4DataPlayerEconomy;
    'name': string;
    'party_id': string;
    'platform': string;
    'puuid': string;
    'session_playtime_in_ms': number;
    'stats': MatchesV4DataPlayerStats;
    'tag': string;
    'team_id': string;
    'tier': TierIdNameCombo;
}
export interface MatchesV4DataPlayerAbilityCasts {
    'ability1'?: number | null;
    'ability2'?: number | null;
    'grenade'?: number | null;
    'ultimate'?: number | null;
}
export interface MatchesV4DataPlayerBehavior {
    'afk_rounds': number;
    'friendly_fire': MatchesV4DataPlayerBehaviorFriendlyFire;
    'rounds_in_spawn': number;
}
export interface MatchesV4DataPlayerBehaviorFriendlyFire {
    'incoming': number;
    'outgoing': number;
}
export interface MatchesV4DataPlayerCustomization {
    'card': string;
    'preferred_level_border'?: string | null;
    'title': string;
}
export interface MatchesV4DataPlayerEconomy {
    'loadout_value': MatchesV4DataPlayerEconomyLoadoutValue;
    'spent': MatchesV4DataPlayerEconomySpent;
}
export interface MatchesV4DataPlayerEconomyLoadoutValue {
    'average': number;
    'overall': number;
}
export interface MatchesV4DataPlayerEconomySpent {
    'average': number;
    'overall': number;
}
export interface MatchesV4DataPlayerStats {
    'assists': number;
    'bodyshots': number;
    'damage': MatchesV4DataPlayerStatsDamage;
    'deaths': number;
    'headshots': number;
    'kills': number;
    'legshots': number;
    'score': number;
}
export interface MatchesV4DataPlayerStatsDamage {
    'dealt': number;
    'received': number;
}
export interface MatchesV4DataRound {
    'ceremony': string;
    'defuse'?: MatchesV4DataRoundDefuse | null;
    'id': number;
    'plant'?: MatchesV4DataRoundPlant | null;
    'result': string;
    'stats': Array<MatchesV4DataRoundPlayerStats>;
    'winning_team': string;
}
export interface MatchesV4DataRoundDefuse {
    'location': MatchesV4DataRoundLocation;
    'player': MatchesV4DataRoundPlayer;
    'player_locations': Array<MatchesV4DataRoundPlayerLocations>;
    'round_time_in_ms': number;
}
export interface MatchesV4DataRoundLocation {
    'x': number;
    'y': number;
}
export interface MatchesV4DataRoundPlant {
    'location': MatchesV4DataRoundLocation;
    'player': MatchesV4DataRoundPlayer;
    'player_locations': Array<MatchesV4DataRoundPlayerLocations>;
    'round_time_in_ms': number;
    'site': string;
}
export interface MatchesV4DataRoundPlayer {
    'name': string;
    'puuid': string;
    'tag': string;
    'team': string;
}
export interface MatchesV4DataRoundPlayerLocations {
    'location': MatchesV4DataRoundLocation;
    'player': MatchesV4DataRoundPlayer;
    'view_radians': number;
}
export interface MatchesV4DataRoundPlayerStats {
    'ability_casts': MatchesV4DataRoundPlayerStatsAbilityCasts;
    'damage_events': Array<MatchesV4DataRoundPlayerStatsDamageEvents>;
    'economy': MatchesV4DataRoundPlayerStatsEconomy;
    'player': MatchesV4DataRoundPlayer;
    'received_penalty': boolean;
    'stats': MatchesV4DataRoundPlayerStatsStats;
    'stayed_in_spawn': boolean;
    'was_afk': boolean;
}
export interface MatchesV4DataRoundPlayerStatsAbilityCasts {
    'ability_1'?: number | null;
    'ability_2'?: number | null;
    'grenade'?: number | null;
    'ultimate'?: number | null;
}
export interface MatchesV4DataRoundPlayerStatsDamageEvents {
    'bodyshots': number;
    'damage': number;
    'headshots': number;
    'legshots': number;
    'player': MatchesV4DataRoundPlayer;
}
export interface MatchesV4DataRoundPlayerStatsEconomy {
    'armor'?: MatchesV4DataRoundPlayerStatsEconomyArmor | null;
    'loadout_value': number;
    'remaining': number;
    'weapon'?: MatchesV4DataRoundPlayerStatsEconomyWeapon | null;
}
export interface MatchesV4DataRoundPlayerStatsEconomyArmor {
    'id': string;
    'name'?: string | null;
}
export interface MatchesV4DataRoundPlayerStatsEconomyWeapon {
    'id'?: string | null;
    'name'?: string | null;
    'type'?: string | null;
}
export interface MatchesV4DataRoundPlayerStatsStats {
    'bodyshots': number;
    'headshots': number;
    'kills': number;
    'legshots': number;
    'score': number;
}
export interface MatchesV4DataTeam {
    'premier_roster'?: MatchesV4DataTeamPremierRoster | null;
    'rounds': MatchesV4DataTeamRounds;
    'team_id': string;
    'won': boolean;
}
export interface MatchesV4DataTeamPremierRoster {
    'customization': MatchesV4DataTeamPremierRosterCustomization;
    'id': string;
    'members': Array<string>;
    'name': string;
    'tag': string;
}
export interface MatchesV4DataTeamPremierRosterCustomization {
    'icon': string;
    'image': string;
    'primary_color': string;
    'secondary_color': string;
    'tertiary_color': string;
}
export interface MatchesV4DataTeamRounds {
    'lost': number;
    'won': number;
}
export interface MatchesV4HistoryResponse {
    'data': Array<MatchesV4Data>;
    'status': number;
}
export interface MatchesV4Response {
    'data': MatchesV4Data;
    'status': number;
}
export interface Pagination {
    'after': number;
    'before': number;
    'returned': number;
    'total': number;
}
export interface PremierSearchResponse {
    'data': Array<PremierTeamLiteResponseData>;
    'status': number;
}
export interface PremierTeamGamesLeagueString {
    'id': string;
    'points_after': number;
    'points_before': number;
    'started_at': string;
}
export interface PremierTeamGamesTournament {
    'matches': Array<string>;
    'placement': number;
    'placement_league_bonus': number;
    'points_after': number;
    'points_before': number;
    'tournament_id': string;
}
export interface PremierTeamHistoryV1Response {
    'data': PremierTeamHistoryV1ResponseData;
    'status': number;
}
export interface PremierTeamHistoryV1ResponseData {
    'league_matches': Array<PremierTeamGamesLeagueString>;
    'tournament_matches': Array<PremierTeamGamesTournament>;
}
export interface PremierTeamLiteResponseData {
    'affinity': string;
    'conference': string;
    'customization': PremierTeamV1ResponseDataCustomization;
    'division': number;
    'id': string;
    'losses': number;
    'name': string;
    'ranking': number;
    'region': string;
    'score': number;
    'tag': string;
    'updated_at': string;
    'wins': number;
}
export interface PremierTeamMember {
    'name'?: string | null;
    'puuid': string;
    'tag'?: string | null;
}
export interface PremierTeamV1Response {
    'data': PremierTeamV1ResponseData;
    'status': number;
}
export interface PremierTeamV1ResponseData {
    'customization': PremierTeamV1ResponseDataCustomization;
    'enrolled': boolean;
    'id': string;
    'member': Array<PremierTeamMember>;
    'name': string;
    'placement': PremierTeamV1ResponseDataPlacement;
    'stats': PremierTeamV1ResponseDataStats;
    'tag': string;
}
export interface PremierTeamV1ResponseDataCustomization {
    'icon': string;
    'image': string;
    'primary': string;
    'secondary': string;
    'tertiary': string;
}
export interface PremierTeamV1ResponseDataPlacement {
    'conference': string;
    'division': number;
    'place': number;
    'points': number;
}
export interface PremierTeamV1ResponseDataStats {
    'losses': number;
    'matches': number;
    'rounds_lost': number;
    'rounds_won': number;
    'wins': number;
}
export interface QueueStatusV1 {
    'data': Array<QueueStatusV1Data>;
    'status': number;
}
export interface QueueStatusV1Data {
    'enabled': boolean;
    'game_rules': QueueStatusV1GameRules;
    'high_skill': QueueStatusV1HighSkill;
    'maps': Array<QueueStatusV1Maps>;
    'mode': string;
    'mode_id': string;
    'number_of_teams': number;
    'party_size': QueueStatusV1PartySize;
    'platforms': Array<string>;
    'ranked': boolean;
    'required_account_level': number;
    'skill_disparity': Array<QueueStatusV1SkillDisparity>;
    'team_size': number;
    'tournament': boolean;
}
export interface QueueStatusV1GameRules {
    'allow_drop_out': boolean;
    'allow_lenient_surrender': boolean;
    'allow_overtime_draw_vote': boolean;
    'assign_random_agents': boolean;
    'overtime_win_by_two': boolean;
    'overtime_win_by_two_capped': boolean;
    'premier_mode': boolean;
    'skip_pregame': boolean;
}
export interface QueueStatusV1HighSkill {
    'max_party_size': number;
    'max_tier': number;
    'min_tier': number;
}
export interface QueueStatusV1IDNamePair {
    'id': number;
    'name': string;
}
export interface QueueStatusV1Map {
    'id': string;
    'name': string;
}
export interface QueueStatusV1Maps {
    'enabled': boolean;
    'map': QueueStatusV1Map;
}
export interface QueueStatusV1PartySize {
    'full_party_bypass': boolean;
    'invalid': Array<number>;
    'max': number;
    'min': number;
}
export interface QueueStatusV1SkillDisparity {
    'max_tier': QueueStatusV1IDNamePair;
    'name': string;
    'tier': number;
}
export interface RawV1ErrorData {
    'code': number;
    'error': boolean;
    'id': string;
}
export interface RawV1Payload {
    'platform'?: string | null;
    'queries'?: string | null;
    'region': string;
    'type': string;
    'value': RawV1PayloadValues;
}
/**
 * @type RawV1PayloadValues
 */
export type RawV1PayloadValues = Array<string> | string;

export interface RawV1Response {
    'data': RawV1ResponseData | null;
    'status': number;
}
/**
 * @type RawV1ResponseData
 */
export type RawV1ResponseData = Array<any> | RawV1ErrorData;

export interface SeasonIdShortCombo {
    'id': string;
    'short': string;
}
export interface SendError {
    'errors': Array<APIError>;
}
export interface StatusIncident {
    'archive_at'?: string | null;
    'created_at': string;
    'id': number;
    'incident_severity': string;
    'maintenance_status'?: string | null;
    'platforms': Array<string>;
    'titles': Array<StatusIncidentContent>;
    'updated_at': string;
    'updates': Array<StatusIncidentUpdate>;
}
export interface StatusIncidentContent {
    'content': string;
    'locale': string;
}
export interface StatusIncidentUpdate {
    'author': string;
    'created_at': string;
    'id': number;
    'publish': boolean;
    'publish_locations': Array<string>;
    'translations': Array<StatusIncidentContent>;
    'updated_at': string;
}
export interface StatusV1 {
    'data': StatusV1Data;
    'status': number;
}
export interface StatusV1Data {
    'incidents': Array<StatusIncident>;
    'maintenances': Array<StatusIncident>;
}
export interface StoreFeaturedV1 {
    'FeaturedBundle': FeaturedBundle;
}
export interface StoreOffersV1 {
    'Offers': Array<StoreOffersV1Offer>;
    'UpgradeCurrencyOffers': Array<StoreOffersV1UpgradeCurrency>;
}
export interface StoreOffersV1Offer {
    'Cost': { [key: string]: number; };
    'IsDirectPurchase': boolean;
    'OfferID': string;
    'Rewards': Array<StoreOffersV1Reward>;
    'StartDate': string;
}
export interface StoreOffersV1Response {
    'data': StoreOffersV1;
    'status': number;
}
export interface StoreOffersV1Reward {
    'ItemID': string;
    'ItemTypeID': string;
    'Quantity': number;
}
export interface StoreOffersV1UpgradeCurrency {
    'DiscountedPercent': number;
    'Offer': StoreOffersV1Offer;
    'OfferID': string;
    'StorefrontItemID': string;
}
export interface StoredMMR {
    'date': string;
    'elo': number;
    'last_mmr_change': number;
    'map': StoredMMRMap;
    'match_id': string;
    'ranking_in_tier': number;
    'season': StoredMMRSeason;
    'tier': StoredMMRTier;
}
export interface StoredMMRMap {
    'id': string;
    'name': string;
}
export interface StoredMMRResponse {
    'data': Array<StoredMMR>;
    'results': Pagination;
    'status': number;
}
export interface StoredMMRSeason {
    'id': string;
    'short': string;
}
export interface StoredMMRTier {
    'id': number;
    'name': string;
}
export interface StoredMMRV2 {
    'date': string;
    'elo': number;
    'last_change': number;
    'map': MapIdNameCombo;
    'match_id': string;
    'refunded_rr': number;
    'rr': number;
    'season': SeasonIdShortCombo;
    'tier': TierIdNameCombo;
    'was_derank_protected': boolean;
}
export interface StoredMMRV2Response {
    'data': Array<StoredMMRV2>;
    'results': Pagination;
    'status': number;
}
export interface StoredMatch {
    'meta': StoredMatchMeta;
    'stats': StoredMatchStats;
    'teams': StoredMatchTeam;
}
export interface StoredMatchMeta {
    'cluster'?: string | null;
    'id': string;
    'map': StoredMatchMetaMap;
    'mode': string;
    'region': string;
    'season': StoredMatchMetaSeason;
    'started_at': string;
    'version': string;
}
export interface StoredMatchMetaMap {
    'id': string;
    'name': string;
}
export interface StoredMatchMetaSeason {
    'id': string;
    'short': string;
}
export interface StoredMatchStats {
    'assists': number;
    'character': StoredMatchStatsCharacter;
    'damage': StoredMatchStatsDamage;
    'deaths': number;
    'kills': number;
    'level': number;
    'puuid': string;
    'score': number;
    'shots': StoredMatchStatsShots;
    'team': string;
    'tier': number;
}
export interface StoredMatchStatsCharacter {
    'id': string;
    'name': string;
}
export interface StoredMatchStatsDamage {
    'made': number;
    'received': number;
}
export interface StoredMatchStatsShots {
    'body': number;
    'head': number;
    'leg': number;
}
export interface StoredMatchTeam {
    'blue': number;
    'red': number;
}
export interface StoredMatchesResponse {
    'data': Array<StoredMatch>;
    'results': Pagination;
    'status': number;
}
export interface TierIdNameCombo {
    'id': number;
    'name': string;
}
export interface VersionV1Data {
    'branch': string;
    'build_date': string;
    'build_ver': string;
    'last_checked': string;
    'region': string;
    'version': number;
    'version_for_api': string;
}
export interface VersionV1Response {
    'data': VersionV1Data;
    'status': number;
}
export interface WebsiteByIdV1Data {
    'banner_url'?: string | null;
    'category': string;
    'content'?: string | null;
    'date': string;
    'description'?: string | null;
    'external_link'?: string | null;
    'title': string;
    'url': string;
}
export interface WebsiteByIdV1Response {
    'data': WebsiteByIdV1Data;
    'status': number;
}
export interface WebsiteV1Data {
    'banner_url'?: string | null;
    'category': string;
    'date': string;
    'description'?: string | null;
    'external_link'?: string | null;
    'id': string;
    'title': string;
    'url': string;
}
export interface WebsiteV1Response {
    'data': Array<WebsiteV1Data>;
    'status': number;
}

/**
 * ValorantApi - axios parameter creator
 */
export const ValorantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] Crosshair code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crosshair: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/crosshair/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Region filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        esportsSchedulesV1: async (region?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/esports/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV1: async (puuid: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getAccountByIdV1', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/account/{puuid}`
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV2: async (puuid: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getAccountByIdV2', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/account/{puuid}`
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1: async (name: string, tag: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getAccountV1', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getAccountV1', 'tag', tag)
            const localVarPath = `/valorant/v1/account/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2: async (name: string, tag: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getAccountV2', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getAccountV2', 'tag', tag)
            const localVarPath = `/valorant/v2/account/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [locale] Locale code (e.g., en-US, de-DE) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentV1: async (locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ById: async (affinity: string, puuid: string, mode?: string, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV3ById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMatchesV3ById', 'puuid', puuid)
            const localVarPath = `/valorant/v3/by-puuid/matches/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {MatchMode} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ByName: async (affinity: string, name: string, tag: string, mode?: MatchMode, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV3ByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMatchesV3ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMatchesV3ByName', 'tag', tag)
            const localVarPath = `/valorant/v3/matches/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ById: async (affinity: string, platform: string, puuid: string, mode?: string, map?: string, size?: number, start?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV4ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMatchesV4ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMatchesV4ById', 'puuid', puuid)
            const localVarPath = `/valorant/v4/by-puuid/matches/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ByName: async (affinity: string, platform: string, name: string, tag: string, mode?: string, map?: string, size?: number, start?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'tag', tag)
            const localVarPath = `/valorant/v4/matches/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryById: async (affinity: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrHistoryById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryByName: async (affinity: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrHistoryByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrHistoryByName', 'tag', tag)
            const localVarPath = `/valorant/v1/mmr-history/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ById: async (affinity: string, platform: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryV2ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrHistoryV2ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrHistoryV2ById', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/mmr-history/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ByName: async (affinity: string, platform: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'tag', tag)
            const localVarPath = `/valorant/v2/mmr-history/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ById: async (affinity: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV1ById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrV1ById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/mmr/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ByName: async (affinity: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV1ByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrV1ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrV1ByName', 'tag', tag)
            const localVarPath = `/valorant/v1/mmr/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ById: async (affinity: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV2ById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrV2ById', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/mmr/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ByName: async (affinity: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV2ByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrV2ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrV2ByName', 'tag', tag)
            const localVarPath = `/valorant/v2/mmr/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ById: async (affinity: string, platform: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV3ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrV3ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrV3ById', 'puuid', puuid)
            const localVarPath = `/valorant/v3/by-puuid/mmr/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ByName: async (affinity: string, platform: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV3ByName', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrV3ByName', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrV3ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrV3ByName', 'tag', tag)
            const localVarPath = `/valorant/v3/mmr/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV1: async (affinity: string, season?: string, name?: string, tag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('leaderboardV1', 'affinity', affinity)
            const localVarPath = `/valorant/v1/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {string} [puuid] Player UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV2: async (affinity: string, season?: string, name?: string, tag?: string, puuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('leaderboardV2', 'affinity', affinity)
            const localVarPath = `/valorant/v2/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (puuid !== undefined) {
                localVarQueryParameter['puuid'] = puuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} [season] Season ID (optional)
         * @param {number} [size] Number of results per page (optional)
         * @param {number} [page] Page number (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV3: async (affinity: string, platform: string, season?: string, size?: number, page?: number, name?: string, tag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('leaderboardV3', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('leaderboardV3', 'platform', platform)
            const localVarPath = `/valorant/v3/leaderboard/{affinity}/{platform}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV2: async (matchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV2', 'matchId', matchId)
            const localVarPath = `/valorant/v2/match/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4: async (affinity: string, matchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('matchV4', 'affinity', affinity)
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV4', 'matchId', matchId)
            const localVarPath = `/valorant/v4/match/{affinity}/{match_id}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('premierById', 'id', id)
            const localVarPath = `/valorant/v1/premier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByIdHistory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('premierByIdHistory', 'id', id)
            const localVarPath = `/valorant/v1/premier/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByName: async (name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('premierByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('premierByName', 'tag', tag)
            const localVarPath = `/valorant/v1/premier/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByNameHistory: async (name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('premierByNameHistory', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('premierByNameHistory', 'tag', tag)
            const localVarPath = `/valorant/v1/premier/{name}/{tag}/history`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [conference] Conference filter (optional)
         * @param {string} [division] Division filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierLeaderboard: async (affinity: string, conference?: string, division?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('premierLeaderboard', 'affinity', affinity)
            const localVarPath = `/valorant/v1/premier/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conference !== undefined) {
                localVarQueryParameter['conference'] = conference;
            }

            if (division !== undefined) {
                localVarQueryParameter['division'] = division;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] Team name to search for (optional)
         * @param {string} [tag] Team tag to search for (optional)
         * @param {string} [id] Team UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierSearch: async (name?: string, tag?: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/premier/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueStatus: async (affinity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('queueStatus', 'affinity', affinity)
            const localVarPath = `/valorant/v1/queue-status/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RawV1Payload} rawV1Payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raw: async (rawV1Payload: RawV1Payload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rawV1Payload' is not null or undefined
            assertParamExists('raw', 'rawV1Payload', rawV1Payload)
            const localVarPath = `/valorant/v1/raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rawV1Payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (affinity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('status', 'affinity', affinity)
            const localVarPath = `/valorant/v1/status/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeFeatured: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('storeFeatured', 'version', version)
            const localVarPath = `/valorant/{version}/store-featured`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOffers: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('storeOffers', 'version', version)
            const localVarPath = `/valorant/{version}/store-offers`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatches: async (affinity: string, name: string, tag: string, mode?: string, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMatches', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('storedMatches', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storedMatches', 'tag', tag)
            const localVarPath = `/valorant/v1/stored-matches/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatchesById: async (affinity: string, puuid: string, mode?: string, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMatchesById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('storedMatchesById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/stored-matches/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistory: async (affinity: string, name: string, tag: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistory', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('storedMmrHistory', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storedMmrHistory', 'tag', tag)
            const localVarPath = `/valorant/v1/stored-mmr-history/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryById: async (affinity: string, puuid: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistoryById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('storedMmrHistoryById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/stored-mmr-history/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2: async (affinity: string, platform: string, name: string, tag: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'tag', tag)
            const localVarPath = `/valorant/v2/stored-mmr-history/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2ById: async (affinity: string, platform: string, puuid: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistoryV2ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('storedMmrHistoryV2ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('storedMmrHistoryV2ById', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/stored-mmr-history/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: async (affinity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('version', 'affinity', affinity)
            const localVarPath = `/valorant/v1/version/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {string} [category] Category filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        website: async (countryCode: string, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('website', 'countryCode', countryCode)
            const localVarPath = `/valorant/v1/website/{country_code}`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dbId Database ID of the website entry
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteById: async (dbId: string, countryCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('websiteById', 'dbId', dbId)
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('websiteById', 'countryCode', countryCode)
            const localVarPath = `/valorant/v1/website/{country_code}/{db_id}`
                .replace(`{${"db_id"}}`, encodeURIComponent(String(dbId)))
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValorantApi - functional programming interface
 */
export const ValorantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValorantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] Crosshair code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crosshair(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crosshair(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.crosshair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [region] Region filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async esportsSchedulesV1(region?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EsportsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.esportsSchedulesV1(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.esportsSchedulesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByIdV1(puuid: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByIdV1(puuid, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByIdV2(puuid: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByIdV2(puuid, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountByIdV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV1(name: string, tag: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV1(name, tag, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV2(name: string, tag: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV2(name, tag, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [locale] Locale code (e.g., en-US, de-DE) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentV1(locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentV1(locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getContentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV3ById(affinity: string, puuid: string, mode?: string, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV3ListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV3ById(affinity, puuid, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV3ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {MatchMode} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV3ByName(affinity: string, name: string, tag: string, mode?: MatchMode, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV3ListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV3ByName(affinity, name, tag, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV3ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV4ById(affinity: string, platform: string, puuid: string, mode?: string, map?: string, size?: number, start?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV4HistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV4ById(affinity, platform, puuid, mode, map, size, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV4ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV4ByName(affinity: string, platform: string, name: string, tag: string, mode?: string, map?: string, size?: number, start?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV4HistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV4ByName(affinity, platform, name, tag, mode, map, size, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV4ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryById(affinity: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryById(affinity, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryByName(affinity: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryByName(affinity, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryV2ById(affinity: string, platform: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryV2ById(affinity, platform, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryV2ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryV2ByName(affinity: string, platform: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryV2ByName(affinity, platform, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryV2ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV1ById(affinity: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV1ById(affinity, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV1ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV1ByName(affinity: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV1ByName(affinity, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV1ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV2ById(affinity: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV2ById(affinity, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV2ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV2ByName(affinity: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV2ByName(affinity, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV2ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV3ById(affinity: string, platform: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV3ById(affinity, platform, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV3ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV3ByName(affinity: string, platform: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV3ByName(affinity, platform, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV3ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardV1(affinity: string, season?: string, name?: string, tag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardV1(affinity, season, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.leaderboardV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {string} [puuid] Player UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardV2(affinity: string, season?: string, name?: string, tag?: string, puuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardV2(affinity, season, name, tag, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.leaderboardV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} [season] Season ID (optional)
         * @param {number} [size] Number of results per page (optional)
         * @param {number} [page] Page number (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardV3(affinity: string, platform: string, season?: string, size?: number, page?: number, name?: string, tag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardV3(affinity, platform, season, size, page, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.leaderboardV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV2(matchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV2(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.matchV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4(affinity: string, matchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV4Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4(affinity, matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.matchV4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierByIdHistory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierByIdHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierByIdHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierByName(name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierByName(name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierByNameHistory(name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamHistoryV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierByNameHistory(name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierByNameHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [conference] Conference filter (optional)
         * @param {string} [division] Division filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierLeaderboard(affinity: string, conference?: string, division?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierLeaderboard(affinity, conference, division, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [name] Team name to search for (optional)
         * @param {string} [tag] Team tag to search for (optional)
         * @param {string} [id] Team UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierSearch(name?: string, tag?: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierSearch(name, tag, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueStatus(affinity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueStatusV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueStatus(affinity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.queueStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RawV1Payload} rawV1Payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async raw(rawV1Payload: RawV1Payload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.raw(rawV1Payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.raw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(affinity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(affinity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.status']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeFeatured(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreFeaturedV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeFeatured(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storeFeatured']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeOffers(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreOffersV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeOffers(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storeOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMatches(affinity: string, name: string, tag: string, mode?: string, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMatchesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMatches(affinity, name, tag, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMatchesById(affinity: string, puuid: string, mode?: string, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMatchesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMatchesById(affinity, puuid, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMatchesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistory(affinity: string, name: string, tag: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistory(affinity, name, tag, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistoryById(affinity: string, puuid: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistoryById(affinity, puuid, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistoryV2(affinity: string, platform: string, name: string, tag: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistoryV2(affinity, platform, name, tag, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistoryV2ById(affinity: string, platform: string, puuid: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistoryV2ById(affinity, platform, puuid, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistoryV2ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async version(affinity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.version(affinity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.version']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {string} [category] Category filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async website(countryCode: string, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.website(countryCode, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.website']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} dbId Database ID of the website entry
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteById(dbId: string, countryCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteByIdV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteById(dbId, countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.websiteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ValorantApi - factory interface
 */
export const ValorantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValorantApiFp(configuration)
    return {
        /**
         * 
         * @param {ValorantApiCrosshairRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crosshair(requestParameters: ValorantApiCrosshairRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.crosshair(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiEsportsSchedulesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        esportsSchedulesV1(requestParameters: ValorantApiEsportsSchedulesV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<EsportsV1Response> {
            return localVarFp.esportsSchedulesV1(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountByIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV1(requestParameters: ValorantApiGetAccountByIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV1Response> {
            return localVarFp.getAccountByIdV1(requestParameters.puuid, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountByIdV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV2(requestParameters: ValorantApiGetAccountByIdV2Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV2Response> {
            return localVarFp.getAccountByIdV2(requestParameters.puuid, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1(requestParameters: ValorantApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV1Response> {
            return localVarFp.getAccountV1(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2(requestParameters: ValorantApiGetAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV2Response> {
            return localVarFp.getAccountV2(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetContentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentV1(requestParameters: ValorantApiGetContentV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<ContentV1Response> {
            return localVarFp.getContentV1(requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV3ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ById(requestParameters: ValorantApiGetMatchesV3ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV3ListResponse> {
            return localVarFp.getMatchesV3ById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV3ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ByName(requestParameters: ValorantApiGetMatchesV3ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV3ListResponse> {
            return localVarFp.getMatchesV3ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV4ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ById(requestParameters: ValorantApiGetMatchesV4ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV4HistoryResponse> {
            return localVarFp.getMatchesV4ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV4ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ByName(requestParameters: ValorantApiGetMatchesV4ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV4HistoryResponse> {
            return localVarFp.getMatchesV4ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryById(requestParameters: ValorantApiGetMmrHistoryByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV1Response> {
            return localVarFp.getMmrHistoryById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryByName(requestParameters: ValorantApiGetMmrHistoryByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV1Response> {
            return localVarFp.getMmrHistoryByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryV2ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ById(requestParameters: ValorantApiGetMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV2Response> {
            return localVarFp.getMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryV2ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ByName(requestParameters: ValorantApiGetMmrHistoryV2ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV2Response> {
            return localVarFp.getMmrHistoryV2ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV1ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ById(requestParameters: ValorantApiGetMmrV1ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV1Response> {
            return localVarFp.getMmrV1ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV1ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ByName(requestParameters: ValorantApiGetMmrV1ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV1Response> {
            return localVarFp.getMmrV1ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV2ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ById(requestParameters: ValorantApiGetMmrV2ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV2Response> {
            return localVarFp.getMmrV2ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV2ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ByName(requestParameters: ValorantApiGetMmrV2ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV2Response> {
            return localVarFp.getMmrV2ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV3ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ById(requestParameters: ValorantApiGetMmrV3ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV3Response> {
            return localVarFp.getMmrV3ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV3ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ByName(requestParameters: ValorantApiGetMmrV3ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV3Response> {
            return localVarFp.getMmrV3ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiLeaderboardV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV1(requestParameters: ValorantApiLeaderboardV1Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.leaderboardV1(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiLeaderboardV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV2(requestParameters: ValorantApiLeaderboardV2Request, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardV2Response> {
            return localVarFp.leaderboardV2(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiLeaderboardV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV3(requestParameters: ValorantApiLeaderboardV3Request, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardV3Response> {
            return localVarFp.leaderboardV3(requestParameters.affinity, requestParameters.platform, requestParameters.season, requestParameters.size, requestParameters.page, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiMatchV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV2(requestParameters: ValorantApiMatchV2Request, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV2Response> {
            return localVarFp.matchV2(requestParameters.matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiMatchV4Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4(requestParameters: ValorantApiMatchV4Request, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV4Response> {
            return localVarFp.matchV4(requestParameters.affinity, requestParameters.matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierById(requestParameters: ValorantApiPremierByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamV1Response> {
            return localVarFp.premierById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByIdHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByIdHistory(requestParameters: ValorantApiPremierByIdHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamV1Response> {
            return localVarFp.premierByIdHistory(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByName(requestParameters: ValorantApiPremierByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamV1Response> {
            return localVarFp.premierByName(requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByNameHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByNameHistory(requestParameters: ValorantApiPremierByNameHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamHistoryV1Response> {
            return localVarFp.premierByNameHistory(requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierLeaderboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierLeaderboard(requestParameters: ValorantApiPremierLeaderboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierSearchResponse> {
            return localVarFp.premierLeaderboard(requestParameters.affinity, requestParameters.conference, requestParameters.division, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierSearch(requestParameters: ValorantApiPremierSearchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PremierSearchResponse> {
            return localVarFp.premierSearch(requestParameters.name, requestParameters.tag, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiQueueStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueStatus(requestParameters: ValorantApiQueueStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueueStatusV1> {
            return localVarFp.queueStatus(requestParameters.affinity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiRawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raw(requestParameters: ValorantApiRawRequest, options?: RawAxiosRequestConfig): AxiosPromise<RawV1Response> {
            return localVarFp.raw(requestParameters.rawV1Payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(requestParameters: ValorantApiStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<StatusV1> {
            return localVarFp.status(requestParameters.affinity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoreFeaturedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeFeatured(requestParameters: ValorantApiStoreFeaturedRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoreFeaturedV1> {
            return localVarFp.storeFeatured(requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoreOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOffers(requestParameters: ValorantApiStoreOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoreOffersV1Response> {
            return localVarFp.storeOffers(requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMatchesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatches(requestParameters: ValorantApiStoredMatchesRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMatchesResponse> {
            return localVarFp.storedMatches(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMatchesByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatchesById(requestParameters: ValorantApiStoredMatchesByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMatchesResponse> {
            return localVarFp.storedMatchesById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistory(requestParameters: ValorantApiStoredMmrHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRResponse> {
            return localVarFp.storedMmrHistory(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryById(requestParameters: ValorantApiStoredMmrHistoryByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRResponse> {
            return localVarFp.storedMmrHistoryById(requestParameters.affinity, requestParameters.puuid, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2(requestParameters: ValorantApiStoredMmrHistoryV2Request, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRV2Response> {
            return localVarFp.storedMmrHistoryV2(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryV2ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2ById(requestParameters: ValorantApiStoredMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRV2Response> {
            return localVarFp.storedMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(requestParameters: ValorantApiVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<VersionV1Response> {
            return localVarFp.version(requestParameters.affinity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiWebsiteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        website(requestParameters: ValorantApiWebsiteRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebsiteV1Response> {
            return localVarFp.website(requestParameters.countryCode, requestParameters.category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiWebsiteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteById(requestParameters: ValorantApiWebsiteByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebsiteByIdV1Response> {
            return localVarFp.websiteById(requestParameters.dbId, requestParameters.countryCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for crosshair operation in ValorantApi.
 */
export interface ValorantApiCrosshairRequest {
    /**
     * Crosshair code
     */
    readonly id?: string
}

/**
 * Request parameters for esportsSchedulesV1 operation in ValorantApi.
 */
export interface ValorantApiEsportsSchedulesV1Request {
    /**
     * Region filter (optional)
     */
    readonly region?: string
}

/**
 * Request parameters for getAccountByIdV1 operation in ValorantApi.
 */
export interface ValorantApiGetAccountByIdV1Request {
    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Bypass cache and refresh (optional)
     */
    readonly force?: boolean
}

/**
 * Request parameters for getAccountByIdV2 operation in ValorantApi.
 */
export interface ValorantApiGetAccountByIdV2Request {
    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Bypass cache and refresh (optional)
     */
    readonly force?: boolean
}

/**
 * Request parameters for getAccountV1 operation in ValorantApi.
 */
export interface ValorantApiGetAccountV1Request {
    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Bypass cache and refresh (optional)
     */
    readonly force?: boolean
}

/**
 * Request parameters for getAccountV2 operation in ValorantApi.
 */
export interface ValorantApiGetAccountV2Request {
    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Bypass cache and refresh (optional)
     */
    readonly force?: boolean
}

/**
 * Request parameters for getContentV1 operation in ValorantApi.
 */
export interface ValorantApiGetContentV1Request {
    /**
     * Locale code (e.g., en-US, de-DE) - optional
     */
    readonly locale?: string
}

/**
 * Request parameters for getMatchesV3ById operation in ValorantApi.
 */
export interface ValorantApiGetMatchesV3ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Game mode filter (optional)
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     */
    readonly map?: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for getMatchesV3ByName operation in ValorantApi.
 */
export interface ValorantApiGetMatchesV3ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Game mode filter (optional)
     */
    readonly mode?: MatchMode

    /**
     * Map filter (optional)
     */
    readonly map?: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for getMatchesV4ById operation in ValorantApi.
 */
export interface ValorantApiGetMatchesV4ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Game mode filter (optional)
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     */
    readonly map?: string

    /**
     * Number of results (optional)
     */
    readonly size?: number

    /**
     * Start index for pagination (optional)
     */
    readonly start?: number
}

/**
 * Request parameters for getMatchesV4ByName operation in ValorantApi.
 */
export interface ValorantApiGetMatchesV4ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Game mode filter (optional)
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     */
    readonly map?: string

    /**
     * Number of results (optional)
     */
    readonly size?: number

    /**
     * Start index for pagination (optional)
     */
    readonly start?: number
}

/**
 * Request parameters for getMmrHistoryById operation in ValorantApi.
 */
export interface ValorantApiGetMmrHistoryByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Player UUID
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrHistoryByName operation in ValorantApi.
 */
export interface ValorantApiGetMmrHistoryByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrHistoryV2ById operation in ValorantApi.
 */
export interface ValorantApiGetMmrHistoryV2ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Player UUID
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrHistoryV2ByName operation in ValorantApi.
 */
export interface ValorantApiGetMmrHistoryV2ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrV1ById operation in ValorantApi.
 */
export interface ValorantApiGetMmrV1ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Player UUID
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrV1ByName operation in ValorantApi.
 */
export interface ValorantApiGetMmrV1ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrV2ById operation in ValorantApi.
 */
export interface ValorantApiGetMmrV2ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Player UUID
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrV2ByName operation in ValorantApi.
 */
export interface ValorantApiGetMmrV2ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrV3ById operation in ValorantApi.
 */
export interface ValorantApiGetMmrV3ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Player UUID
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrV3ByName operation in ValorantApi.
 */
export interface ValorantApiGetMmrV3ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string
}

/**
 * Request parameters for leaderboardV1 operation in ValorantApi.
 */
export interface ValorantApiLeaderboardV1Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Season ID (optional)
     */
    readonly season?: string

    /**
     * Player name to search for (optional)
     */
    readonly name?: string

    /**
     * Player tag to search for (optional)
     */
    readonly tag?: string
}

/**
 * Request parameters for leaderboardV2 operation in ValorantApi.
 */
export interface ValorantApiLeaderboardV2Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Season ID (optional)
     */
    readonly season?: string

    /**
     * Player name to search for (optional)
     */
    readonly name?: string

    /**
     * Player tag to search for (optional)
     */
    readonly tag?: string

    /**
     * Player UUID to search for (optional)
     */
    readonly puuid?: string
}

/**
 * Request parameters for leaderboardV3 operation in ValorantApi.
 */
export interface ValorantApiLeaderboardV3Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Season ID (optional)
     */
    readonly season?: string

    /**
     * Number of results per page (optional)
     */
    readonly size?: number

    /**
     * Page number (optional)
     */
    readonly page?: number

    /**
     * Player name to search for (optional)
     */
    readonly name?: string

    /**
     * Player tag to search for (optional)
     */
    readonly tag?: string
}

/**
 * Request parameters for matchV2 operation in ValorantApi.
 */
export interface ValorantApiMatchV2Request {
    /**
     * Match UUID
     */
    readonly matchId: string
}

/**
 * Request parameters for matchV4 operation in ValorantApi.
 */
export interface ValorantApiMatchV4Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Match UUID
     */
    readonly matchId: string
}

/**
 * Request parameters for premierById operation in ValorantApi.
 */
export interface ValorantApiPremierByIdRequest {
    /**
     * Team UUID
     */
    readonly id: string
}

/**
 * Request parameters for premierByIdHistory operation in ValorantApi.
 */
export interface ValorantApiPremierByIdHistoryRequest {
    /**
     * Team UUID
     */
    readonly id: string
}

/**
 * Request parameters for premierByName operation in ValorantApi.
 */
export interface ValorantApiPremierByNameRequest {
    /**
     * Team name
     */
    readonly name: string

    /**
     * Team tag
     */
    readonly tag: string
}

/**
 * Request parameters for premierByNameHistory operation in ValorantApi.
 */
export interface ValorantApiPremierByNameHistoryRequest {
    /**
     * Team name
     */
    readonly name: string

    /**
     * Team tag
     */
    readonly tag: string
}

/**
 * Request parameters for premierLeaderboard operation in ValorantApi.
 */
export interface ValorantApiPremierLeaderboardRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Conference filter (optional)
     */
    readonly conference?: string

    /**
     * Division filter (optional)
     */
    readonly division?: string
}

/**
 * Request parameters for premierSearch operation in ValorantApi.
 */
export interface ValorantApiPremierSearchRequest {
    /**
     * Team name to search for (optional)
     */
    readonly name?: string

    /**
     * Team tag to search for (optional)
     */
    readonly tag?: string

    /**
     * Team UUID to search for (optional)
     */
    readonly id?: string
}

/**
 * Request parameters for queueStatus operation in ValorantApi.
 */
export interface ValorantApiQueueStatusRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string
}

/**
 * Request parameters for raw operation in ValorantApi.
 */
export interface ValorantApiRawRequest {
    readonly rawV1Payload: RawV1Payload
}

/**
 * Request parameters for status operation in ValorantApi.
 */
export interface ValorantApiStatusRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string
}

/**
 * Request parameters for storeFeatured operation in ValorantApi.
 */
export interface ValorantApiStoreFeaturedRequest {
    /**
     * API version (v1, v2)
     */
    readonly version: string
}

/**
 * Request parameters for storeOffers operation in ValorantApi.
 */
export interface ValorantApiStoreOffersRequest {
    /**
     * API version (v1, v2)
     */
    readonly version: string
}

/**
 * Request parameters for storedMatches operation in ValorantApi.
 */
export interface ValorantApiStoredMatchesRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Game mode filter (optional)
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     */
    readonly map?: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for storedMatchesById operation in ValorantApi.
 */
export interface ValorantApiStoredMatchesByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Game mode filter (optional)
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     */
    readonly map?: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistory operation in ValorantApi.
 */
export interface ValorantApiStoredMmrHistoryRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistoryById operation in ValorantApi.
 */
export interface ValorantApiStoredMmrHistoryByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistoryV2 operation in ValorantApi.
 */
export interface ValorantApiStoredMmrHistoryV2Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Riot ID name
     */
    readonly name: string

    /**
     * Riot ID tag
     */
    readonly tag: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistoryV2ById operation in ValorantApi.
 */
export interface ValorantApiStoredMmrHistoryV2ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     */
    readonly platform: string

    /**
     * Player UUID
     */
    readonly puuid: string

    /**
     * Number of results (optional)
     */
    readonly size?: number
}

/**
 * Request parameters for version operation in ValorantApi.
 */
export interface ValorantApiVersionRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     */
    readonly affinity: string
}

/**
 * Request parameters for website operation in ValorantApi.
 */
export interface ValorantApiWebsiteRequest {
    /**
     * Country code (e.g., en-us, de-de)
     */
    readonly countryCode: string

    /**
     * Category filter (optional)
     */
    readonly category?: string
}

/**
 * Request parameters for websiteById operation in ValorantApi.
 */
export interface ValorantApiWebsiteByIdRequest {
    /**
     * Database ID of the website entry
     */
    readonly dbId: string

    /**
     * Country code (e.g., en-us, de-de)
     */
    readonly countryCode: string
}

/**
 * ValorantApi - object-oriented interface
 */
export class ValorantApi extends BaseAPI {
    /**
     * 
     * @param {ValorantApiCrosshairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public crosshair(requestParameters: ValorantApiCrosshairRequest = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).crosshair(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiEsportsSchedulesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public esportsSchedulesV1(requestParameters: ValorantApiEsportsSchedulesV1Request = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).esportsSchedulesV1(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountByIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountByIdV1(requestParameters: ValorantApiGetAccountByIdV1Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountByIdV1(requestParameters.puuid, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountByIdV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountByIdV2(requestParameters: ValorantApiGetAccountByIdV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountByIdV2(requestParameters.puuid, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountV1(requestParameters: ValorantApiGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountV1(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountV2(requestParameters: ValorantApiGetAccountV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountV2(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetContentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContentV1(requestParameters: ValorantApiGetContentV1Request = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getContentV1(requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV3ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMatchesV3ById(requestParameters: ValorantApiGetMatchesV3ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV3ById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV3ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMatchesV3ByName(requestParameters: ValorantApiGetMatchesV3ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV3ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV4ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMatchesV4ById(requestParameters: ValorantApiGetMatchesV4ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV4ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV4ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMatchesV4ByName(requestParameters: ValorantApiGetMatchesV4ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV4ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrHistoryById(requestParameters: ValorantApiGetMmrHistoryByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrHistoryByName(requestParameters: ValorantApiGetMmrHistoryByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryV2ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrHistoryV2ById(requestParameters: ValorantApiGetMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryV2ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrHistoryV2ByName(requestParameters: ValorantApiGetMmrHistoryV2ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryV2ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV1ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrV1ById(requestParameters: ValorantApiGetMmrV1ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV1ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV1ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrV1ByName(requestParameters: ValorantApiGetMmrV1ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV1ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV2ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrV2ById(requestParameters: ValorantApiGetMmrV2ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV2ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV2ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrV2ByName(requestParameters: ValorantApiGetMmrV2ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV2ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV3ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrV3ById(requestParameters: ValorantApiGetMmrV3ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV3ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV3ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMmrV3ByName(requestParameters: ValorantApiGetMmrV3ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV3ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiLeaderboardV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboardV1(requestParameters: ValorantApiLeaderboardV1Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).leaderboardV1(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiLeaderboardV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboardV2(requestParameters: ValorantApiLeaderboardV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).leaderboardV2(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiLeaderboardV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboardV3(requestParameters: ValorantApiLeaderboardV3Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).leaderboardV3(requestParameters.affinity, requestParameters.platform, requestParameters.season, requestParameters.size, requestParameters.page, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiMatchV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public matchV2(requestParameters: ValorantApiMatchV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).matchV2(requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiMatchV4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public matchV4(requestParameters: ValorantApiMatchV4Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).matchV4(requestParameters.affinity, requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public premierById(requestParameters: ValorantApiPremierByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByIdHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public premierByIdHistory(requestParameters: ValorantApiPremierByIdHistoryRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierByIdHistory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public premierByName(requestParameters: ValorantApiPremierByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierByName(requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByNameHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public premierByNameHistory(requestParameters: ValorantApiPremierByNameHistoryRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierByNameHistory(requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierLeaderboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public premierLeaderboard(requestParameters: ValorantApiPremierLeaderboardRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierLeaderboard(requestParameters.affinity, requestParameters.conference, requestParameters.division, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public premierSearch(requestParameters: ValorantApiPremierSearchRequest = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierSearch(requestParameters.name, requestParameters.tag, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiQueueStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queueStatus(requestParameters: ValorantApiQueueStatusRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).queueStatus(requestParameters.affinity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiRawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public raw(requestParameters: ValorantApiRawRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).raw(requestParameters.rawV1Payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public status(requestParameters: ValorantApiStatusRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).status(requestParameters.affinity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoreFeaturedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storeFeatured(requestParameters: ValorantApiStoreFeaturedRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storeFeatured(requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoreOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storeOffers(requestParameters: ValorantApiStoreOffersRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storeOffers(requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storedMatches(requestParameters: ValorantApiStoredMatchesRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMatches(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMatchesByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storedMatchesById(requestParameters: ValorantApiStoredMatchesByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMatchesById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storedMmrHistory(requestParameters: ValorantApiStoredMmrHistoryRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistory(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storedMmrHistoryById(requestParameters: ValorantApiStoredMmrHistoryByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistoryById(requestParameters.affinity, requestParameters.puuid, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storedMmrHistoryV2(requestParameters: ValorantApiStoredMmrHistoryV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistoryV2(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryV2ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public storedMmrHistoryV2ById(requestParameters: ValorantApiStoredMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public version(requestParameters: ValorantApiVersionRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).version(requestParameters.affinity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiWebsiteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public website(requestParameters: ValorantApiWebsiteRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).website(requestParameters.countryCode, requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiWebsiteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public websiteById(requestParameters: ValorantApiWebsiteByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).websiteById(requestParameters.dbId, requestParameters.countryCode, options).then((request) => request(this.axios, this.basePath));
    }
}



