/* tslint:disable */
/* eslint-disable */
/**
 * HenrikDev API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface APIError
 */
export interface APIError {
    /**
     * 
     * @type {number}
     * @memberof APIError
     */
    'code': number;
    /**
     * 
     * @type {any}
     * @memberof APIError
     */
    'details'?: any;
    /**
     * 
     * @type {string}
     * @memberof APIError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof APIError
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface AccountV1Data
 */
export interface AccountV1Data {
    /**
     * 
     * @type {number}
     * @memberof AccountV1Data
     */
    'account_level': number;
    /**
     * 
     * @type {AccountV1DataCard}
     * @memberof AccountV1Data
     */
    'card': AccountV1DataCard;
    /**
     * 
     * @type {string}
     * @memberof AccountV1Data
     */
    'last_update': string;
    /**
     * 
     * @type {number}
     * @memberof AccountV1Data
     */
    'last_update_raw': number;
    /**
     * 
     * @type {string}
     * @memberof AccountV1Data
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV1Data
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV1Data
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV1Data
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface AccountV1DataCard
 */
export interface AccountV1DataCard {
    /**
     * 
     * @type {string}
     * @memberof AccountV1DataCard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV1DataCard
     */
    'large': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV1DataCard
     */
    'small': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV1DataCard
     */
    'wide': string;
}
/**
 * 
 * @export
 * @interface AccountV1Response
 */
export interface AccountV1Response {
    /**
     * 
     * @type {AccountV1Data}
     * @memberof AccountV1Response
     */
    'data': AccountV1Data;
    /**
     * 
     * @type {number}
     * @memberof AccountV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface AccountV2Data
 */
export interface AccountV2Data {
    /**
     * 
     * @type {number}
     * @memberof AccountV2Data
     */
    'account_level': number;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'card': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountV2Data
     */
    'platforms': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof AccountV2Data
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface AccountV2Response
 */
export interface AccountV2Response {
    /**
     * 
     * @type {AccountV2Data}
     * @memberof AccountV2Response
     */
    'data': AccountV2Data;
    /**
     * 
     * @type {number}
     * @memberof AccountV2Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface AgentIdNameCombo
 */
export interface AgentIdNameCombo {
    /**
     * 
     * @type {string}
     * @memberof AgentIdNameCombo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AgentIdNameCombo
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'CurrencyID': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'DataAssetID': string;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'DurationRemainingInSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'ID': string;
    /**
     * 
     * @type {Array<BundleItem>}
     * @memberof Bundle
     */
    'Items': Array<BundleItem>;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'TotalDiscountPercent': number;
    /**
     * 
     * @type {boolean}
     * @memberof Bundle
     */
    'WholesaleOnly': boolean;
}
/**
 * 
 * @export
 * @interface BundleItem
 */
export interface BundleItem {
    /**
     * 
     * @type {number}
     * @memberof BundleItem
     */
    'BasePrice': number;
    /**
     * 
     * @type {string}
     * @memberof BundleItem
     */
    'CurrencyID': string;
    /**
     * 
     * @type {number}
     * @memberof BundleItem
     */
    'DiscountPercent': number;
    /**
     * 
     * @type {number}
     * @memberof BundleItem
     */
    'DiscountedPrice': number;
    /**
     * 
     * @type {boolean}
     * @memberof BundleItem
     */
    'IsPromoItem': boolean;
    /**
     * 
     * @type {Item}
     * @memberof BundleItem
     */
    'Item': Item;
}
/**
 * 
 * @export
 * @interface ContentItem
 */
export interface ContentItem {
    /**
     * 
     * @type {string}
     * @memberof ContentItem
     */
    'assetName': string;
    /**
     * 
     * @type {string}
     * @memberof ContentItem
     */
    'id'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ContentItem
     */
    'localizedNames'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ContentItem
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ContentV1
 */
export interface ContentV1 {
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'acts': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'ceremonies': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'characters': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'charmLevels': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'charms': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'chromas': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'equips': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'gameModes': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'maps': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'playerCards': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'playerTitles': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'skinLevels': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'skins': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'sprayLevels': Array<ContentItem>;
    /**
     * 
     * @type {Array<ContentItem>}
     * @memberof ContentV1
     */
    'sprays': Array<ContentItem>;
    /**
     * 
     * @type {string}
     * @memberof ContentV1
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ContentV1Response
 */
export interface ContentV1Response {
    /**
     * 
     * @type {ContentV1}
     * @memberof ContentV1Response
     */
    'data': ContentV1;
    /**
     * 
     * @type {number}
     * @memberof ContentV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface EsportsV1Data
 */
export interface EsportsV1Data {
    /**
     * 
     * @type {string}
     * @memberof EsportsV1Data
     */
    'date': string;
    /**
     * 
     * @type {EsportsV1DataLeague}
     * @memberof EsportsV1Data
     */
    'league': EsportsV1DataLeague;
    /**
     * 
     * @type {EsportsV1DataMatch}
     * @memberof EsportsV1Data
     */
    'match': EsportsV1DataMatch;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1Data
     */
    'state': string;
    /**
     * 
     * @type {EsportsV1DataTournament}
     * @memberof EsportsV1Data
     */
    'tournament': EsportsV1DataTournament;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1Data
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1Data
     */
    'vod'?: string | null;
}
/**
 * 
 * @export
 * @interface EsportsV1DataLeague
 */
export interface EsportsV1DataLeague {
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataLeague
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataLeague
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataLeague
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataLeague
     */
    'region': string;
}
/**
 * 
 * @export
 * @interface EsportsV1DataMatch
 */
export interface EsportsV1DataMatch {
    /**
     * 
     * @type {EsportsV1DataMatchGameType}
     * @memberof EsportsV1DataMatch
     */
    'game_type': EsportsV1DataMatchGameType;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataMatch
     */
    'id'?: string | null;
    /**
     * 
     * @type {Array<EsportsV1DataMatchTeams>}
     * @memberof EsportsV1DataMatch
     */
    'teams': Array<EsportsV1DataMatchTeams>;
}
/**
 * 
 * @export
 * @interface EsportsV1DataMatchGameType
 */
export interface EsportsV1DataMatchGameType {
    /**
     * 
     * @type {number}
     * @memberof EsportsV1DataMatchGameType
     */
    'count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataMatchGameType
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface EsportsV1DataMatchTeams
 */
export interface EsportsV1DataMatchTeams {
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataMatchTeams
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof EsportsV1DataMatchTeams
     */
    'game_wins': number;
    /**
     * 
     * @type {boolean}
     * @memberof EsportsV1DataMatchTeams
     */
    'has_won': boolean;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataMatchTeams
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataMatchTeams
     */
    'name': string;
    /**
     * 
     * @type {EsportsV1DataMatchTeamsRecord}
     * @memberof EsportsV1DataMatchTeams
     */
    'record': EsportsV1DataMatchTeamsRecord;
}
/**
 * 
 * @export
 * @interface EsportsV1DataMatchTeamsRecord
 */
export interface EsportsV1DataMatchTeamsRecord {
    /**
     * 
     * @type {number}
     * @memberof EsportsV1DataMatchTeamsRecord
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof EsportsV1DataMatchTeamsRecord
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface EsportsV1DataTournament
 */
export interface EsportsV1DataTournament {
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataTournament
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EsportsV1DataTournament
     */
    'season': string;
}
/**
 * 
 * @export
 * @interface EsportsV1Response
 */
export interface EsportsV1Response {
    /**
     * 
     * @type {Array<EsportsV1Data>}
     * @memberof EsportsV1Response
     */
    'data': Array<EsportsV1Data>;
    /**
     * 
     * @type {number}
     * @memberof EsportsV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface FeaturedBundle
 */
export interface FeaturedBundle {
    /**
     * 
     * @type {Bundle}
     * @memberof FeaturedBundle
     */
    'Bundle': Bundle;
    /**
     * 
     * @type {number}
     * @memberof FeaturedBundle
     */
    'BundleRemainingDurationInSeconds': number;
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof FeaturedBundle
     */
    'Bundles': Array<Bundle>;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'Amount': number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'ItemID': string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'ItemTypeID': string;
}
/**
 * 
 * @export
 * @interface LeaderboardPVPPlayer
 */
export interface LeaderboardPVPPlayer {
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardPVPPlayer
     */
    'IsAnonymized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardPVPPlayer
     */
    'IsBanned': boolean;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardPVPPlayer
     */
    'PlayerCardID': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardPVPPlayer
     */
    'TitleID': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardPVPPlayer
     */
    'competitiveTier': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardPVPPlayer
     */
    'gameName': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardPVPPlayer
     */
    'leaderboardRank': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardPVPPlayer
     */
    'numberOfWins': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardPVPPlayer
     */
    'puuid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardPVPPlayer
     */
    'rankedRating': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardPVPPlayer
     */
    'tagLine': string;
}
/**
 * 
 * @export
 * @interface LeaderboardV2Response
 */
export interface LeaderboardV2Response {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'immortal_1_threshold': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'immortal_2_threshold': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'immortal_3_threshold': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'last_update': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'next_update': number;
    /**
     * 
     * @type {Array<LeaderboardPVPPlayer>}
     * @memberof LeaderboardV2Response
     */
    'players': Array<LeaderboardPVPPlayer>;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'radiant_threshold': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV2Response
     */
    'total_players': number;
}
/**
 * 
 * @export
 * @interface LeaderboardV3Data
 */
export interface LeaderboardV3Data {
    /**
     * 
     * @type {Array<LeaderboardV3DataPlayer>}
     * @memberof LeaderboardV3Data
     */
    'players': Array<LeaderboardV3DataPlayer>;
    /**
     * 
     * @type {Array<LeaderboardV3DataThreshold>}
     * @memberof LeaderboardV3Data
     */
    'thresholds': Array<LeaderboardV3DataThreshold>;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3Data
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface LeaderboardV3DataPlayer
 */
export interface LeaderboardV3DataPlayer {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataPlayer
     */
    'card': string;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardV3DataPlayer
     */
    'is_anonymized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardV3DataPlayer
     */
    'is_banned': boolean;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataPlayer
     */
    'leaderboard_rank': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataPlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataPlayer
     */
    'puuid'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataPlayer
     */
    'rr': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataPlayer
     */
    'tag': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataPlayer
     */
    'tier': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataPlayer
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataPlayer
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataPlayer
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface LeaderboardV3DataThreshold
 */
export interface LeaderboardV3DataThreshold {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataThreshold
     */
    'start_index': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataThreshold
     */
    'threshold': number;
    /**
     * 
     * @type {LeaderboardV3DataThresholdTier}
     * @memberof LeaderboardV3DataThreshold
     */
    'tier': LeaderboardV3DataThresholdTier;
}
/**
 * 
 * @export
 * @interface LeaderboardV3DataThresholdTier
 */
export interface LeaderboardV3DataThresholdTier {
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3DataThresholdTier
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardV3DataThresholdTier
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LeaderboardV3Response
 */
export interface LeaderboardV3Response {
    /**
     * 
     * @type {LeaderboardV3Data}
     * @memberof LeaderboardV3Response
     */
    'data': LeaderboardV3Data;
    /**
     * 
     * @type {Pagination}
     * @memberof LeaderboardV3Response
     */
    'results': Pagination;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardV3Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MMRDataImages
 */
export interface MMRDataImages {
    /**
     * 
     * @type {string}
     * @memberof MMRDataImages
     */
    'large': string;
    /**
     * 
     * @type {string}
     * @memberof MMRDataImages
     */
    'small': string;
    /**
     * 
     * @type {string}
     * @memberof MMRDataImages
     */
    'triangle_down': string;
    /**
     * 
     * @type {string}
     * @memberof MMRDataImages
     */
    'triangle_up': string;
}
/**
 * 
 * @export
 * @interface MMRHistoryV1Data
 */
export interface MMRHistoryV1Data {
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV1Data
     */
    'currenttier': number;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1Data
     */
    'currenttierpatched': string;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1Data
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV1Data
     */
    'date_raw': number;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV1Data
     */
    'elo': number;
    /**
     * 
     * @type {MMRDataImages}
     * @memberof MMRHistoryV1Data
     */
    'images': MMRDataImages;
    /**
     * 
     * @type {MMRHistoryV1DataMap}
     * @memberof MMRHistoryV1Data
     */
    'map': MMRHistoryV1DataMap;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1Data
     */
    'match_id': string;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV1Data
     */
    'mmr_change_to_last_game': number;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV1Data
     */
    'ranking_in_tier': number;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1Data
     */
    'season_id': string;
}
/**
 * 
 * @export
 * @interface MMRHistoryV1DataMap
 */
export interface MMRHistoryV1DataMap {
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1DataMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1DataMap
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface MMRHistoryV1Response
 */
export interface MMRHistoryV1Response {
    /**
     * 
     * @type {Array<MMRHistoryV1Data>}
     * @memberof MMRHistoryV1Response
     */
    'data': Array<MMRHistoryV1Data>;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1Response
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV1Response
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV1Response
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface MMRHistoryV2Data
 */
export interface MMRHistoryV2Data {
    /**
     * 
     * @type {MMRV3Account}
     * @memberof MMRHistoryV2Data
     */
    'account': MMRV3Account;
    /**
     * 
     * @type {Array<MMRHistoryV2History>}
     * @memberof MMRHistoryV2Data
     */
    'history': Array<MMRHistoryV2History>;
}
/**
 * 
 * @export
 * @interface MMRHistoryV2History
 */
export interface MMRHistoryV2History {
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV2History
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV2History
     */
    'elo': number;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV2History
     */
    'last_change': number;
    /**
     * 
     * @type {MapIdNameCombo}
     * @memberof MMRHistoryV2History
     */
    'map': MapIdNameCombo;
    /**
     * 
     * @type {string}
     * @memberof MMRHistoryV2History
     */
    'match_id': string;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV2History
     */
    'refunded_rr': number;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV2History
     */
    'rr': number;
    /**
     * 
     * @type {SeasonIdShortCombo}
     * @memberof MMRHistoryV2History
     */
    'season': SeasonIdShortCombo;
    /**
     * 
     * @type {TierIdNameCombo}
     * @memberof MMRHistoryV2History
     */
    'tier': TierIdNameCombo;
    /**
     * 
     * @type {boolean}
     * @memberof MMRHistoryV2History
     */
    'was_derank_protected': boolean;
}
/**
 * 
 * @export
 * @interface MMRHistoryV2Response
 */
export interface MMRHistoryV2Response {
    /**
     * 
     * @type {MMRHistoryV2Data}
     * @memberof MMRHistoryV2Response
     */
    'data': MMRHistoryV2Data;
    /**
     * 
     * @type {number}
     * @memberof MMRHistoryV2Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MMRV1Data
 */
export interface MMRV1Data {
    /**
     * 
     * @type {number}
     * @memberof MMRV1Data
     */
    'currenttier': number;
    /**
     * 
     * @type {string}
     * @memberof MMRV1Data
     */
    'currenttierpatched': string;
    /**
     * 
     * @type {number}
     * @memberof MMRV1Data
     */
    'elo': number;
    /**
     * 
     * @type {MMRDataImages}
     * @memberof MMRV1Data
     */
    'images': MMRDataImages;
    /**
     * 
     * @type {number}
     * @memberof MMRV1Data
     */
    'mmr_change_to_last_game': number;
    /**
     * 
     * @type {string}
     * @memberof MMRV1Data
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof MMRV1Data
     */
    'old': boolean;
    /**
     * 
     * @type {number}
     * @memberof MMRV1Data
     */
    'ranking_in_tier': number;
    /**
     * 
     * @type {string}
     * @memberof MMRV1Data
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface MMRV1Response
 */
export interface MMRV1Response {
    /**
     * 
     * @type {MMRV1Data}
     * @memberof MMRV1Response
     */
    'data': MMRV1Data;
    /**
     * 
     * @type {number}
     * @memberof MMRV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MMRV2CurrentData
 */
export interface MMRV2CurrentData {
    /**
     * 
     * @type {number}
     * @memberof MMRV2CurrentData
     */
    'currenttier': number;
    /**
     * 
     * @type {string}
     * @memberof MMRV2CurrentData
     */
    'currenttierpatched': string;
    /**
     * 
     * @type {number}
     * @memberof MMRV2CurrentData
     */
    'elo': number;
    /**
     * 
     * @type {number}
     * @memberof MMRV2CurrentData
     */
    'games_needed_for_rating': number;
    /**
     * 
     * @type {MMRDataImages}
     * @memberof MMRV2CurrentData
     */
    'images': MMRDataImages;
    /**
     * 
     * @type {number}
     * @memberof MMRV2CurrentData
     */
    'mmr_change_to_last_game': number;
    /**
     * 
     * @type {boolean}
     * @memberof MMRV2CurrentData
     */
    'old': boolean;
    /**
     * 
     * @type {number}
     * @memberof MMRV2CurrentData
     */
    'ranking_in_tier': number;
}
/**
 * 
 * @export
 * @interface MMRV2Data
 */
export interface MMRV2Data {
    /**
     * 
     * @type {any}
     * @memberof MMRV2Data
     */
    'by_season': any;
    /**
     * 
     * @type {MMRV2CurrentData}
     * @memberof MMRV2Data
     */
    'current_data': MMRV2CurrentData;
    /**
     * 
     * @type {MMRV2HighestRank}
     * @memberof MMRV2Data
     */
    'highest_rank': MMRV2HighestRank;
    /**
     * 
     * @type {string}
     * @memberof MMRV2Data
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MMRV2Data
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MMRV2Data
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface MMRV2HighestRank
 */
export interface MMRV2HighestRank {
    /**
     * 
     * @type {boolean}
     * @memberof MMRV2HighestRank
     */
    'old': boolean;
    /**
     * 
     * @type {string}
     * @memberof MMRV2HighestRank
     */
    'patched_tier': string;
    /**
     * 
     * @type {string}
     * @memberof MMRV2HighestRank
     */
    'season': string;
    /**
     * 
     * @type {number}
     * @memberof MMRV2HighestRank
     */
    'tier': number;
}
/**
 * 
 * @export
 * @interface MMRV2Response
 */
export interface MMRV2Response {
    /**
     * 
     * @type {MMRV2Data}
     * @memberof MMRV2Response
     */
    'data': MMRV2Data;
    /**
     * 
     * @type {number}
     * @memberof MMRV2Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MMRV3Account
 */
export interface MMRV3Account {
    /**
     * 
     * @type {string}
     * @memberof MMRV3Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MMRV3Account
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MMRV3Account
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface MMRV3Current
 */
export interface MMRV3Current {
    /**
     * 
     * @type {number}
     * @memberof MMRV3Current
     */
    'elo': number;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Current
     */
    'games_needed_for_rating': number;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Current
     */
    'last_change': number;
    /**
     * 
     * @type {MMRV3LeaderboardPlacement}
     * @memberof MMRV3Current
     */
    'leaderboard_placement'?: MMRV3LeaderboardPlacement | null;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Current
     */
    'rank_protection_shields': number;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Current
     */
    'rr': number;
    /**
     * 
     * @type {TierIdNameCombo}
     * @memberof MMRV3Current
     */
    'tier': TierIdNameCombo;
}
/**
 * 
 * @export
 * @interface MMRV3Data
 */
export interface MMRV3Data {
    /**
     * 
     * @type {MMRV3Account}
     * @memberof MMRV3Data
     */
    'account': MMRV3Account;
    /**
     * 
     * @type {MMRV3Current}
     * @memberof MMRV3Data
     */
    'current': MMRV3Current;
    /**
     * 
     * @type {MMRV3Peak}
     * @memberof MMRV3Data
     */
    'peak'?: MMRV3Peak | null;
    /**
     * 
     * @type {Array<MMRV3Seasonal>}
     * @memberof MMRV3Data
     */
    'seasonal': Array<MMRV3Seasonal>;
}
/**
 * 
 * @export
 * @interface MMRV3LeaderboardPlacement
 */
export interface MMRV3LeaderboardPlacement {
    /**
     * 
     * @type {number}
     * @memberof MMRV3LeaderboardPlacement
     */
    'rank': number;
    /**
     * 
     * @type {string}
     * @memberof MMRV3LeaderboardPlacement
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface MMRV3Peak
 */
export interface MMRV3Peak {
    /**
     * 
     * @type {string}
     * @memberof MMRV3Peak
     */
    'ranking_schema': string;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Peak
     */
    'rr': number;
    /**
     * 
     * @type {SeasonIdShortCombo}
     * @memberof MMRV3Peak
     */
    'season': SeasonIdShortCombo;
    /**
     * 
     * @type {TierIdNameCombo}
     * @memberof MMRV3Peak
     */
    'tier': TierIdNameCombo;
}
/**
 * 
 * @export
 * @interface MMRV3Response
 */
export interface MMRV3Response {
    /**
     * 
     * @type {MMRV3Data}
     * @memberof MMRV3Response
     */
    'data': MMRV3Data;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MMRV3Seasonal
 */
export interface MMRV3Seasonal {
    /**
     * 
     * @type {Array<TierIdNameCombo>}
     * @memberof MMRV3Seasonal
     */
    'act_wins': Array<TierIdNameCombo>;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Seasonal
     */
    'end_rr': number;
    /**
     * 
     * @type {TierIdNameCombo}
     * @memberof MMRV3Seasonal
     */
    'end_tier': TierIdNameCombo;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Seasonal
     */
    'games': number;
    /**
     * 
     * @type {MMRV3LeaderboardPlacement}
     * @memberof MMRV3Seasonal
     */
    'leaderboard_placement'?: MMRV3LeaderboardPlacement | null;
    /**
     * 
     * @type {string}
     * @memberof MMRV3Seasonal
     */
    'ranking_schema': string;
    /**
     * 
     * @type {SeasonIdShortCombo}
     * @memberof MMRV3Seasonal
     */
    'season': SeasonIdShortCombo;
    /**
     * 
     * @type {number}
     * @memberof MMRV3Seasonal
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface MapIdNameCombo
 */
export interface MapIdNameCombo {
    /**
     * 
     * @type {string}
     * @memberof MapIdNameCombo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MapIdNameCombo
     */
    'name': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MatchMode = {
    Competitive: 'Competitive',
    Unrated: 'Unrated',
    Custom: 'Custom',
    Practice: 'Practice',
    Unknown: 'Unknown'
} as const;

export type MatchMode = typeof MatchMode[keyof typeof MatchMode];


/**
 * 
 * @export
 * @interface MatchesV2Data
 */
export interface MatchesV2Data {
    /**
     * 
     * @type {Array<MatchesV2DataCoach>}
     * @memberof MatchesV2Data
     */
    'coaches': Array<MatchesV2DataCoach>;
    /**
     * 
     * @type {Array<MatchesV2DataKill>}
     * @memberof MatchesV2Data
     */
    'kills': Array<MatchesV2DataKill>;
    /**
     * 
     * @type {MatchesV2DataMetadata}
     * @memberof MatchesV2Data
     */
    'metadata': MatchesV2DataMetadata;
    /**
     * 
     * @type {Array<MatchesV2DataObserver>}
     * @memberof MatchesV2Data
     */
    'observers': Array<MatchesV2DataObserver>;
    /**
     * 
     * @type {MatchesV2DataPlayers}
     * @memberof MatchesV2Data
     */
    'players': MatchesV2DataPlayers;
    /**
     * 
     * @type {Array<MatchesV2DataRound>}
     * @memberof MatchesV2Data
     */
    'rounds': Array<MatchesV2DataRound>;
    /**
     * 
     * @type {MatchesV2DataTeams}
     * @memberof MatchesV2Data
     */
    'teams': MatchesV2DataTeams;
}
/**
 * 
 * @export
 * @interface MatchesV2DataCoach
 */
export interface MatchesV2DataCoach {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataCoach
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataCoach
     */
    'team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataKill
 */
export interface MatchesV2DataKill {
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerStatsKillEventsAssistants>}
     * @memberof MatchesV2DataKill
     */
    'assistants': Array<MatchesV2DataRoundPlayerStatsKillEventsAssistants>;
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsKillEventsAssets}
     * @memberof MatchesV2DataKill
     */
    'damage_weapon_assets': MatchesV2DataRoundPlayerStatsKillEventsAssets;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'damage_weapon_id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'damage_weapon_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataKill
     */
    'kill_time_in_match': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataKill
     */
    'kill_time_in_round': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'killer_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'killer_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'killer_team': string;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerLocationsOnEvent>}
     * @memberof MatchesV2DataKill
     */
    'player_locations_on_kill': Array<MatchesV2DataRoundPlayerLocationsOnEvent>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataKill
     */
    'round': number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataKill
     */
    'secondary_fire_mode': boolean;
    /**
     * 
     * @type {MatchesV2DataRoundEventLocation}
     * @memberof MatchesV2DataKill
     */
    'victim_death_location': MatchesV2DataRoundEventLocation;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'victim_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'victim_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataKill
     */
    'victim_team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataMetadata
 */
export interface MatchesV2DataMetadata {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'cluster'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataMetadata
     */
    'game_length': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataMetadata
     */
    'game_start': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'game_start_patched': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'game_version': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'map'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'matchid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'mode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'mode_id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'platform': string;
    /**
     * 
     * @type {MatchesV2DataMetadataPremierInfo}
     * @memberof MatchesV2DataMetadata
     */
    'premier_info': MatchesV2DataMetadataPremierInfo;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'queue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'region'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataMetadata
     */
    'rounds_played': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadata
     */
    'season_id': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataMetadataPremierInfo
 */
export interface MatchesV2DataMetadataPremierInfo {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadataPremierInfo
     */
    'matchup_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataMetadataPremierInfo
     */
    'tournament_id'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataObserver
 */
export interface MatchesV2DataObserver {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataObserver
     */
    'level': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'party_id': string;
    /**
     * 
     * @type {MatchesV2DataPlatform}
     * @memberof MatchesV2DataObserver
     */
    'platform': MatchesV2DataPlatform;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'player_card': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'player_title': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'puuid': string;
    /**
     * 
     * @type {MatchesV2DataPlayerSessionPlaytime}
     * @memberof MatchesV2DataObserver
     */
    'session_playtime': MatchesV2DataPlayerSessionPlaytime;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataObserver
     */
    'team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlatform
 */
export interface MatchesV2DataPlatform {
    /**
     * 
     * @type {MatchesV2DataPlatformOs}
     * @memberof MatchesV2DataPlatform
     */
    'os': MatchesV2DataPlatformOs;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlatform
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlatformOs
 */
export interface MatchesV2DataPlatformOs {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlatformOs
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlatformOs
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayer
 */
export interface MatchesV2DataPlayer {
    /**
     * 
     * @type {MatchesV2DataPlayerAbilityCasts}
     * @memberof MatchesV2DataPlayer
     */
    'ability_casts': MatchesV2DataPlayerAbilityCasts;
    /**
     * 
     * @type {MatchesV2DataPlayerAssets}
     * @memberof MatchesV2DataPlayer
     */
    'assets': MatchesV2DataPlayerAssets;
    /**
     * 
     * @type {MatchesV2DataPlayerBehavior}
     * @memberof MatchesV2DataPlayer
     */
    'behavior': MatchesV2DataPlayerBehavior;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'character'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayer
     */
    'currenttier': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'currenttier_patched': string;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayer
     */
    'damage_made': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayer
     */
    'damage_received': number;
    /**
     * 
     * @type {MatchesV2DataPlayerEconomy}
     * @memberof MatchesV2DataPlayer
     */
    'economy': MatchesV2DataPlayerEconomy;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayer
     */
    'level': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'party_id': string;
    /**
     * 
     * @type {MatchesV2DataPlatform}
     * @memberof MatchesV2DataPlayer
     */
    'platform': MatchesV2DataPlatform;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'player_card': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'player_title': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'puuid': string;
    /**
     * 
     * @type {MatchesV2DataPlayerSessionPlaytime}
     * @memberof MatchesV2DataPlayer
     */
    'session_playtime': MatchesV2DataPlayerSessionPlaytime;
    /**
     * 
     * @type {MatchesV2DataPlayerStats}
     * @memberof MatchesV2DataPlayer
     */
    'stats': MatchesV2DataPlayerStats;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayer
     */
    'team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerAbilityCasts
 */
export interface MatchesV2DataPlayerAbilityCasts {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerAbilityCasts
     */
    'c_cast'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerAbilityCasts
     */
    'e_cast'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerAbilityCasts
     */
    'q_cast'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerAbilityCasts
     */
    'x_cast'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerAssets
 */
export interface MatchesV2DataPlayerAssets {
    /**
     * 
     * @type {MatchesV2DataPlayerAssetsAgent}
     * @memberof MatchesV2DataPlayerAssets
     */
    'agent': MatchesV2DataPlayerAssetsAgent;
    /**
     * 
     * @type {MatchesV2DataPlayerAssetsCard}
     * @memberof MatchesV2DataPlayerAssets
     */
    'card': MatchesV2DataPlayerAssetsCard;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerAssetsAgent
 */
export interface MatchesV2DataPlayerAssetsAgent {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsAgent
     */
    'bust': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsAgent
     */
    'full': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsAgent
     */
    'killfeed': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsAgent
     */
    'small': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerAssetsCard
 */
export interface MatchesV2DataPlayerAssetsCard {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsCard
     */
    'large': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsCard
     */
    'small': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataPlayerAssetsCard
     */
    'wide': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerBehavior
 */
export interface MatchesV2DataPlayerBehavior {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerBehavior
     */
    'afk_rounds': number;
    /**
     * 
     * @type {MatchesV2DataPlayerBehaviorFriendlyFire}
     * @memberof MatchesV2DataPlayerBehavior
     */
    'friendly_fire': MatchesV2DataPlayerBehaviorFriendlyFire;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerBehavior
     */
    'rounds_in_spawn'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerBehaviorFriendlyFire
 */
export interface MatchesV2DataPlayerBehaviorFriendlyFire {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerBehaviorFriendlyFire
     */
    'incoming'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerBehaviorFriendlyFire
     */
    'outgoing'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerEconomy
 */
export interface MatchesV2DataPlayerEconomy {
    /**
     * 
     * @type {MatchesV2DataPlayerEconomyValue}
     * @memberof MatchesV2DataPlayerEconomy
     */
    'loadout_value': MatchesV2DataPlayerEconomyValue;
    /**
     * 
     * @type {MatchesV2DataPlayerEconomyValue}
     * @memberof MatchesV2DataPlayerEconomy
     */
    'spent': MatchesV2DataPlayerEconomyValue;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerEconomyValue
 */
export interface MatchesV2DataPlayerEconomyValue {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerEconomyValue
     */
    'average': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerEconomyValue
     */
    'overall': number;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerSessionPlaytime
 */
export interface MatchesV2DataPlayerSessionPlaytime {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerSessionPlaytime
     */
    'milliseconds': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerSessionPlaytime
     */
    'minutes': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerSessionPlaytime
     */
    'seconds': number;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayerStats
 */
export interface MatchesV2DataPlayerStats {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'assists': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'bodyshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'deaths': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'headshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'kills': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'legshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataPlayerStats
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface MatchesV2DataPlayers
 */
export interface MatchesV2DataPlayers {
    /**
     * 
     * @type {Array<MatchesV2DataPlayer>}
     * @memberof MatchesV2DataPlayers
     */
    'all_players': Array<MatchesV2DataPlayer>;
    /**
     * 
     * @type {Array<MatchesV2DataPlayer>}
     * @memberof MatchesV2DataPlayers
     */
    'blue': Array<MatchesV2DataPlayer>;
    /**
     * 
     * @type {Array<MatchesV2DataPlayer>}
     * @memberof MatchesV2DataPlayers
     */
    'red': Array<MatchesV2DataPlayer>;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRound
 */
export interface MatchesV2DataRound {
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataRound
     */
    'bomb_defused': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataRound
     */
    'bomb_planted': boolean;
    /**
     * 
     * @type {MatchesV2DataRoundDefuseEvents}
     * @memberof MatchesV2DataRound
     */
    'defuse_events': MatchesV2DataRoundDefuseEvents;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRound
     */
    'end_type': string;
    /**
     * 
     * @type {MatchesV2DataRoundPlantEvents}
     * @memberof MatchesV2DataRound
     */
    'plant_events': MatchesV2DataRoundPlantEvents;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerStats>}
     * @memberof MatchesV2DataRound
     */
    'player_stats': Array<MatchesV2DataRoundPlayerStats>;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRound
     */
    'winning_team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundDefuseEvents
 */
export interface MatchesV2DataRoundDefuseEvents {
    /**
     * 
     * @type {MatchesV2DataRoundEventLocation}
     * @memberof MatchesV2DataRoundDefuseEvents
     */
    'defuse_location'?: MatchesV2DataRoundEventLocation | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundDefuseEvents
     */
    'defuse_time_in_round'?: number | null;
    /**
     * 
     * @type {MatchesV2DataRoundPlayer}
     * @memberof MatchesV2DataRoundDefuseEvents
     */
    'defused_by'?: MatchesV2DataRoundPlayer | null;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerLocationsOnEvent>}
     * @memberof MatchesV2DataRoundDefuseEvents
     */
    'player_locations_on_defuse'?: Array<MatchesV2DataRoundPlayerLocationsOnEvent> | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundEventLocation
 */
export interface MatchesV2DataRoundEventLocation {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundEventLocation
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundEventLocation
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlantEvents
 */
export interface MatchesV2DataRoundPlantEvents {
    /**
     * 
     * @type {MatchesV2DataRoundEventLocation}
     * @memberof MatchesV2DataRoundPlantEvents
     */
    'plant_location'?: MatchesV2DataRoundEventLocation | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlantEvents
     */
    'plant_site'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlantEvents
     */
    'plant_time_in_round'?: number | null;
    /**
     * 
     * @type {MatchesV2DataRoundPlayer}
     * @memberof MatchesV2DataRoundPlantEvents
     */
    'planted_by'?: MatchesV2DataRoundPlayer | null;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerLocationsOnEvent>}
     * @memberof MatchesV2DataRoundPlantEvents
     */
    'player_locations_on_plant'?: Array<MatchesV2DataRoundPlayerLocationsOnEvent> | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayer
 */
export interface MatchesV2DataRoundPlayer {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayer
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayer
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayer
     */
    'team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerLocationsOnEvent
 */
export interface MatchesV2DataRoundPlayerLocationsOnEvent {
    /**
     * 
     * @type {MatchesV2DataRoundEventLocation}
     * @memberof MatchesV2DataRoundPlayerLocationsOnEvent
     */
    'location': MatchesV2DataRoundEventLocation;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerLocationsOnEvent
     */
    'player_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerLocationsOnEvent
     */
    'player_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerLocationsOnEvent
     */
    'player_team': string;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerLocationsOnEvent
     */
    'view_radians': number;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStats
 */
export interface MatchesV2DataRoundPlayerStats {
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsAbilityCasts}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'ability_casts': MatchesV2DataRoundPlayerStatsAbilityCasts;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'bodyshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'damage': number;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerStatsDamageEvents>}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'damage_events': Array<MatchesV2DataRoundPlayerStatsDamageEvents>;
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsEconomy}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'economy': MatchesV2DataRoundPlayerStatsEconomy;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'headshots': number;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerStatsKillEvents>}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'kill_events': Array<MatchesV2DataRoundPlayerStatsKillEvents>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'kills': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'legshots': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'player_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'player_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'player_team': string;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'score': number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'stayed_in_spawn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'was_afk': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataRoundPlayerStats
     */
    'was_penalized': boolean;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsAbilityCasts
 */
export interface MatchesV2DataRoundPlayerStatsAbilityCasts {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsAbilityCasts
     */
    'c_casts'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsAbilityCasts
     */
    'e_casts'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsAbilityCasts
     */
    'q_casts'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsAbilityCasts
     */
    'x_casts'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsDamageEvents
 */
export interface MatchesV2DataRoundPlayerStatsDamageEvents {
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'bodyshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'damage': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'headshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'legshots': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'receiver_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'receiver_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsDamageEvents
     */
    'receiver_team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsEconomy
 */
export interface MatchesV2DataRoundPlayerStatsEconomy {
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor}
     * @memberof MatchesV2DataRoundPlayerStatsEconomy
     */
    'armor': MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsEconomy
     */
    'loadout_value': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsEconomy
     */
    'remaining': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsEconomy
     */
    'spent': number;
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon}
     * @memberof MatchesV2DataRoundPlayerStatsEconomy
     */
    'weapon': MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor
 */
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor {
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor
     */
    'assets': MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentArmor
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets
 */
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets
     */
    'display_icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets
     */
    'killfeed_icon'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor
 */
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentAssetsArmor
     */
    'display_icon'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon
 */
export interface MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon {
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon
     */
    'assets': MatchesV2DataRoundPlayerStatsEconomyEquipmentAssets;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsEconomyEquipmentWeapon
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsKillEvents
 */
export interface MatchesV2DataRoundPlayerStatsKillEvents {
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerStatsKillEventsAssistants>}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'assistants': Array<MatchesV2DataRoundPlayerStatsKillEventsAssistants>;
    /**
     * 
     * @type {MatchesV2DataRoundPlayerStatsKillEventsAssets}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'damage_weapon_assets': MatchesV2DataRoundPlayerStatsKillEventsAssets;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'damage_weapon_id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'damage_weapon_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'kill_time_in_match': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'kill_time_in_round': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'killer_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'killer_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'killer_team': string;
    /**
     * 
     * @type {Array<MatchesV2DataRoundPlayerLocationsOnEvent>}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'player_locations_on_kill': Array<MatchesV2DataRoundPlayerLocationsOnEvent>;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'secondary_fire_mode': boolean;
    /**
     * 
     * @type {MatchesV2DataRoundEventLocation}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'victim_death_location': MatchesV2DataRoundEventLocation;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'victim_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'victim_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEvents
     */
    'victim_team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsKillEventsAssets
 */
export interface MatchesV2DataRoundPlayerStatsKillEventsAssets {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEventsAssets
     */
    'display_icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEventsAssets
     */
    'killfeed_icon'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataRoundPlayerStatsKillEventsAssistants
 */
export interface MatchesV2DataRoundPlayerStatsKillEventsAssistants {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEventsAssistants
     */
    'assistant_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEventsAssistants
     */
    'assistant_puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataRoundPlayerStatsKillEventsAssistants
     */
    'assistant_team': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataTeam
 */
export interface MatchesV2DataTeam {
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV2DataTeam
     */
    'has_won'?: boolean | null;
    /**
     * 
     * @type {MatchesV2DataTeamRoster}
     * @memberof MatchesV2DataTeam
     */
    'roster'?: MatchesV2DataTeamRoster | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataTeam
     */
    'rounds_lost'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2DataTeam
     */
    'rounds_won'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV2DataTeamRoster
 */
export interface MatchesV2DataTeamRoster {
    /**
     * 
     * @type {MatchesV2DataTeamRosterCustomization}
     * @memberof MatchesV2DataTeamRoster
     */
    'customization': MatchesV2DataTeamRosterCustomization;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRoster
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchesV2DataTeamRoster
     */
    'members': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRoster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRoster
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataTeamRosterCustomization
 */
export interface MatchesV2DataTeamRosterCustomization {
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRosterCustomization
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRosterCustomization
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRosterCustomization
     */
    'primary_color': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRosterCustomization
     */
    'secondary_color': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV2DataTeamRosterCustomization
     */
    'tertiary_color': string;
}
/**
 * 
 * @export
 * @interface MatchesV2DataTeams
 */
export interface MatchesV2DataTeams {
    /**
     * 
     * @type {MatchesV2DataTeam}
     * @memberof MatchesV2DataTeams
     */
    'blue': MatchesV2DataTeam;
    /**
     * 
     * @type {MatchesV2DataTeam}
     * @memberof MatchesV2DataTeams
     */
    'red': MatchesV2DataTeam;
}
/**
 * 
 * @export
 * @interface MatchesV2Response
 */
export interface MatchesV2Response {
    /**
     * 
     * @type {MatchesV2Data}
     * @memberof MatchesV2Response
     */
    'data': MatchesV2Data;
    /**
     * 
     * @type {number}
     * @memberof MatchesV2Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MatchesV3ListResponse
 */
export interface MatchesV3ListResponse {
    /**
     * 
     * @type {Array<MatchesV3ListResponseData>}
     * @memberof MatchesV3ListResponse
     */
    'data': Array<MatchesV3ListResponseData>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV3ListResponse
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MatchesV3ListResponseData
 */
export interface MatchesV3ListResponseData {
    /**
     * 
     * @type {Array<MatchesV2DataCoach>}
     * @memberof MatchesV3ListResponseData
     */
    'coaches': Array<MatchesV2DataCoach>;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV3ListResponseData
     */
    'is_available': boolean;
    /**
     * 
     * @type {Array<MatchesV2DataKill>}
     * @memberof MatchesV3ListResponseData
     */
    'kills': Array<MatchesV2DataKill>;
    /**
     * 
     * @type {MatchesV2DataMetadata}
     * @memberof MatchesV3ListResponseData
     */
    'metadata'?: MatchesV2DataMetadata | null;
    /**
     * 
     * @type {Array<MatchesV2DataObserver>}
     * @memberof MatchesV3ListResponseData
     */
    'observers': Array<MatchesV2DataObserver>;
    /**
     * 
     * @type {MatchesV2DataPlayers}
     * @memberof MatchesV3ListResponseData
     */
    'players'?: MatchesV2DataPlayers | null;
    /**
     * 
     * @type {Array<MatchesV2DataRound>}
     * @memberof MatchesV3ListResponseData
     */
    'rounds': Array<MatchesV2DataRound>;
    /**
     * 
     * @type {MatchesV2DataTeams}
     * @memberof MatchesV3ListResponseData
     */
    'teams'?: MatchesV2DataTeams | null;
}
/**
 * 
 * @export
 * @interface MatchesV4Data
 */
export interface MatchesV4Data {
    /**
     * 
     * @type {Array<MatchesV4DataCoach>}
     * @memberof MatchesV4Data
     */
    'coaches': Array<MatchesV4DataCoach>;
    /**
     * 
     * @type {Array<MatchesV4DataKill>}
     * @memberof MatchesV4Data
     */
    'kills': Array<MatchesV4DataKill>;
    /**
     * 
     * @type {MatchesV4DataMetadata}
     * @memberof MatchesV4Data
     */
    'metadata': MatchesV4DataMetadata;
    /**
     * 
     * @type {Array<MatchesV4DataObserver>}
     * @memberof MatchesV4Data
     */
    'observers': Array<MatchesV4DataObserver>;
    /**
     * 
     * @type {Array<MatchesV4DataPlayer>}
     * @memberof MatchesV4Data
     */
    'players': Array<MatchesV4DataPlayer>;
    /**
     * 
     * @type {Array<MatchesV4DataRound>}
     * @memberof MatchesV4Data
     */
    'rounds': Array<MatchesV4DataRound>;
    /**
     * 
     * @type {Array<MatchesV4DataTeam>}
     * @memberof MatchesV4Data
     */
    'teams': Array<MatchesV4DataTeam>;
}
/**
 * 
 * @export
 * @interface MatchesV4DataCoach
 */
export interface MatchesV4DataCoach {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataCoach
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataCoach
     */
    'team_id': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataKill
 */
export interface MatchesV4DataKill {
    /**
     * 
     * @type {Array<MatchesV4DataRoundPlayer>}
     * @memberof MatchesV4DataKill
     */
    'assistants': Array<MatchesV4DataRoundPlayer>;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataKill
     */
    'killer': MatchesV4DataRoundPlayer;
    /**
     * 
     * @type {MatchesV4DataRoundLocation}
     * @memberof MatchesV4DataKill
     */
    'location': MatchesV4DataRoundLocation;
    /**
     * 
     * @type {Array<MatchesV4DataRoundPlayerLocations>}
     * @memberof MatchesV4DataKill
     */
    'player_locations': Array<MatchesV4DataRoundPlayerLocations>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataKill
     */
    'round': number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV4DataKill
     */
    'secondary_fire_mode': boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataKill
     */
    'time_in_match_in_ms': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataKill
     */
    'time_in_round_in_ms': number;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataKill
     */
    'victim': MatchesV4DataRoundPlayer;
    /**
     * 
     * @type {MatchesV4DataRoundPlayerStatsEconomyWeapon}
     * @memberof MatchesV4DataKill
     */
    'weapon': MatchesV4DataRoundPlayerStatsEconomyWeapon;
}
/**
 * 
 * @export
 * @interface MatchesV4DataMetadata
 */
export interface MatchesV4DataMetadata {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadata
     */
    'cluster'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataMetadata
     */
    'game_length_in_ms': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadata
     */
    'game_version': string;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV4DataMetadata
     */
    'is_completed': boolean;
    /**
     * 
     * @type {MapIdNameCombo}
     * @memberof MatchesV4DataMetadata
     */
    'map': MapIdNameCombo;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadata
     */
    'match_id': string;
    /**
     * 
     * @type {Array<MatchesV4DataMetadataPartyRRPenalty>}
     * @memberof MatchesV4DataMetadata
     */
    'party_rr_penaltys': Array<MatchesV4DataMetadataPartyRRPenalty>;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadata
     */
    'platform': string;
    /**
     * 
     * @type {any}
     * @memberof MatchesV4DataMetadata
     */
    'premier'?: any;
    /**
     * 
     * @type {MatchesV4DataMetadataQueue}
     * @memberof MatchesV4DataMetadata
     */
    'queue': MatchesV4DataMetadataQueue;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadata
     */
    'region'?: string | null;
    /**
     * 
     * @type {SeasonIdShortCombo}
     * @memberof MatchesV4DataMetadata
     */
    'season': SeasonIdShortCombo;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadata
     */
    'started_at': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataMetadataPartyRRPenalty
 */
export interface MatchesV4DataMetadataPartyRRPenalty {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadataPartyRRPenalty
     */
    'party_id': string;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataMetadataPartyRRPenalty
     */
    'penalty': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataMetadataQueue
 */
export interface MatchesV4DataMetadataQueue {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadataQueue
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadataQueue
     */
    'mode_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataMetadataQueue
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV4DataObserver
 */
export interface MatchesV4DataObserver {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataObserver
     */
    'account_level': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataObserver
     */
    'card_id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataObserver
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataObserver
     */
    'party_id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataObserver
     */
    'puuid': string;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataObserver
     */
    'session_playtime_in_ms': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataObserver
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataObserver
     */
    'title_id': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayer
 */
export interface MatchesV4DataPlayer {
    /**
     * 
     * @type {MatchesV4DataPlayerAbilityCasts}
     * @memberof MatchesV4DataPlayer
     */
    'ability_casts': MatchesV4DataPlayerAbilityCasts;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayer
     */
    'account_level': number;
    /**
     * 
     * @type {AgentIdNameCombo}
     * @memberof MatchesV4DataPlayer
     */
    'agent': AgentIdNameCombo;
    /**
     * 
     * @type {MatchesV4DataPlayerBehavior}
     * @memberof MatchesV4DataPlayer
     */
    'behavior': MatchesV4DataPlayerBehavior;
    /**
     * 
     * @type {MatchesV4DataPlayerCustomization}
     * @memberof MatchesV4DataPlayer
     */
    'customization': MatchesV4DataPlayerCustomization;
    /**
     * 
     * @type {MatchesV4DataPlayerEconomy}
     * @memberof MatchesV4DataPlayer
     */
    'economy': MatchesV4DataPlayerEconomy;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayer
     */
    'party_id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayer
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayer
     */
    'puuid': string;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayer
     */
    'session_playtime_in_ms': number;
    /**
     * 
     * @type {MatchesV4DataPlayerStats}
     * @memberof MatchesV4DataPlayer
     */
    'stats': MatchesV4DataPlayerStats;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayer
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayer
     */
    'team_id': string;
    /**
     * 
     * @type {TierIdNameCombo}
     * @memberof MatchesV4DataPlayer
     */
    'tier': TierIdNameCombo;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerAbilityCasts
 */
export interface MatchesV4DataPlayerAbilityCasts {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerAbilityCasts
     */
    'ability1'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerAbilityCasts
     */
    'ability2'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerAbilityCasts
     */
    'grenade'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerAbilityCasts
     */
    'ultimate'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerBehavior
 */
export interface MatchesV4DataPlayerBehavior {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerBehavior
     */
    'afk_rounds': number;
    /**
     * 
     * @type {MatchesV4DataPlayerBehaviorFriendlyFire}
     * @memberof MatchesV4DataPlayerBehavior
     */
    'friendly_fire': MatchesV4DataPlayerBehaviorFriendlyFire;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerBehavior
     */
    'rounds_in_spawn': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerBehaviorFriendlyFire
 */
export interface MatchesV4DataPlayerBehaviorFriendlyFire {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerBehaviorFriendlyFire
     */
    'incoming': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerBehaviorFriendlyFire
     */
    'outgoing': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerCustomization
 */
export interface MatchesV4DataPlayerCustomization {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayerCustomization
     */
    'card': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayerCustomization
     */
    'preferred_level_border'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataPlayerCustomization
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerEconomy
 */
export interface MatchesV4DataPlayerEconomy {
    /**
     * 
     * @type {MatchesV4DataPlayerEconomyLoadoutValue}
     * @memberof MatchesV4DataPlayerEconomy
     */
    'loadout_value': MatchesV4DataPlayerEconomyLoadoutValue;
    /**
     * 
     * @type {MatchesV4DataPlayerEconomySpent}
     * @memberof MatchesV4DataPlayerEconomy
     */
    'spent': MatchesV4DataPlayerEconomySpent;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerEconomyLoadoutValue
 */
export interface MatchesV4DataPlayerEconomyLoadoutValue {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerEconomyLoadoutValue
     */
    'average': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerEconomyLoadoutValue
     */
    'overall': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerEconomySpent
 */
export interface MatchesV4DataPlayerEconomySpent {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerEconomySpent
     */
    'average': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerEconomySpent
     */
    'overall': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerStats
 */
export interface MatchesV4DataPlayerStats {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'assists': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'bodyshots': number;
    /**
     * 
     * @type {MatchesV4DataPlayerStatsDamage}
     * @memberof MatchesV4DataPlayerStats
     */
    'damage': MatchesV4DataPlayerStatsDamage;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'deaths': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'headshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'kills': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'legshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStats
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataPlayerStatsDamage
 */
export interface MatchesV4DataPlayerStatsDamage {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStatsDamage
     */
    'dealt': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataPlayerStatsDamage
     */
    'received': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRound
 */
export interface MatchesV4DataRound {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRound
     */
    'ceremony': string;
    /**
     * 
     * @type {MatchesV4DataRoundDefuse}
     * @memberof MatchesV4DataRound
     */
    'defuse'?: MatchesV4DataRoundDefuse | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRound
     */
    'id': number;
    /**
     * 
     * @type {MatchesV4DataRoundPlant}
     * @memberof MatchesV4DataRound
     */
    'plant'?: MatchesV4DataRoundPlant | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRound
     */
    'result': string;
    /**
     * 
     * @type {Array<MatchesV4DataRoundPlayerStats>}
     * @memberof MatchesV4DataRound
     */
    'stats': Array<MatchesV4DataRoundPlayerStats>;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRound
     */
    'winning_team': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundDefuse
 */
export interface MatchesV4DataRoundDefuse {
    /**
     * 
     * @type {MatchesV4DataRoundLocation}
     * @memberof MatchesV4DataRoundDefuse
     */
    'location': MatchesV4DataRoundLocation;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataRoundDefuse
     */
    'player': MatchesV4DataRoundPlayer;
    /**
     * 
     * @type {Array<MatchesV4DataRoundPlayerLocations>}
     * @memberof MatchesV4DataRoundDefuse
     */
    'player_locations': Array<MatchesV4DataRoundPlayerLocations>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundDefuse
     */
    'round_time_in_ms': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundLocation
 */
export interface MatchesV4DataRoundLocation {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundLocation
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundLocation
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlant
 */
export interface MatchesV4DataRoundPlant {
    /**
     * 
     * @type {MatchesV4DataRoundLocation}
     * @memberof MatchesV4DataRoundPlant
     */
    'location': MatchesV4DataRoundLocation;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataRoundPlant
     */
    'player': MatchesV4DataRoundPlayer;
    /**
     * 
     * @type {Array<MatchesV4DataRoundPlayerLocations>}
     * @memberof MatchesV4DataRoundPlant
     */
    'player_locations': Array<MatchesV4DataRoundPlayerLocations>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlant
     */
    'round_time_in_ms': number;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlant
     */
    'site': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayer
 */
export interface MatchesV4DataRoundPlayer {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayer
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayer
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayer
     */
    'team': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerLocations
 */
export interface MatchesV4DataRoundPlayerLocations {
    /**
     * 
     * @type {MatchesV4DataRoundLocation}
     * @memberof MatchesV4DataRoundPlayerLocations
     */
    'location': MatchesV4DataRoundLocation;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataRoundPlayerLocations
     */
    'player': MatchesV4DataRoundPlayer;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerLocations
     */
    'view_radians': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStats
 */
export interface MatchesV4DataRoundPlayerStats {
    /**
     * 
     * @type {MatchesV4DataRoundPlayerStatsAbilityCasts}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'ability_casts': MatchesV4DataRoundPlayerStatsAbilityCasts;
    /**
     * 
     * @type {Array<MatchesV4DataRoundPlayerStatsDamageEvents>}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'damage_events': Array<MatchesV4DataRoundPlayerStatsDamageEvents>;
    /**
     * 
     * @type {MatchesV4DataRoundPlayerStatsEconomy}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'economy': MatchesV4DataRoundPlayerStatsEconomy;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'player': MatchesV4DataRoundPlayer;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'received_penalty': boolean;
    /**
     * 
     * @type {MatchesV4DataRoundPlayerStatsStats}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'stats': MatchesV4DataRoundPlayerStatsStats;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'stayed_in_spawn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV4DataRoundPlayerStats
     */
    'was_afk': boolean;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStatsAbilityCasts
 */
export interface MatchesV4DataRoundPlayerStatsAbilityCasts {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsAbilityCasts
     */
    'ability_1'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsAbilityCasts
     */
    'ability_2'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsAbilityCasts
     */
    'grenade'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsAbilityCasts
     */
    'ultimate'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStatsDamageEvents
 */
export interface MatchesV4DataRoundPlayerStatsDamageEvents {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsDamageEvents
     */
    'bodyshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsDamageEvents
     */
    'damage': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsDamageEvents
     */
    'headshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsDamageEvents
     */
    'legshots': number;
    /**
     * 
     * @type {MatchesV4DataRoundPlayer}
     * @memberof MatchesV4DataRoundPlayerStatsDamageEvents
     */
    'player': MatchesV4DataRoundPlayer;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStatsEconomy
 */
export interface MatchesV4DataRoundPlayerStatsEconomy {
    /**
     * 
     * @type {MatchesV4DataRoundPlayerStatsEconomyArmor}
     * @memberof MatchesV4DataRoundPlayerStatsEconomy
     */
    'armor'?: MatchesV4DataRoundPlayerStatsEconomyArmor | null;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsEconomy
     */
    'loadout_value': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsEconomy
     */
    'remaining': number;
    /**
     * 
     * @type {MatchesV4DataRoundPlayerStatsEconomyWeapon}
     * @memberof MatchesV4DataRoundPlayerStatsEconomy
     */
    'weapon'?: MatchesV4DataRoundPlayerStatsEconomyWeapon | null;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStatsEconomyArmor
 */
export interface MatchesV4DataRoundPlayerStatsEconomyArmor {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayerStatsEconomyArmor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayerStatsEconomyArmor
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStatsEconomyWeapon
 */
export interface MatchesV4DataRoundPlayerStatsEconomyWeapon {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayerStatsEconomyWeapon
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayerStatsEconomyWeapon
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataRoundPlayerStatsEconomyWeapon
     */
    'type'?: string | null;
}
/**
 * 
 * @export
 * @interface MatchesV4DataRoundPlayerStatsStats
 */
export interface MatchesV4DataRoundPlayerStatsStats {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsStats
     */
    'bodyshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsStats
     */
    'headshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsStats
     */
    'kills': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsStats
     */
    'legshots': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataRoundPlayerStatsStats
     */
    'score': number;
}
/**
 * 
 * @export
 * @interface MatchesV4DataTeam
 */
export interface MatchesV4DataTeam {
    /**
     * 
     * @type {MatchesV4DataTeamPremierRoster}
     * @memberof MatchesV4DataTeam
     */
    'premier_roster'?: MatchesV4DataTeamPremierRoster | null;
    /**
     * 
     * @type {MatchesV4DataTeamRounds}
     * @memberof MatchesV4DataTeam
     */
    'rounds': MatchesV4DataTeamRounds;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeam
     */
    'team_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof MatchesV4DataTeam
     */
    'won': boolean;
}
/**
 * 
 * @export
 * @interface MatchesV4DataTeamPremierRoster
 */
export interface MatchesV4DataTeamPremierRoster {
    /**
     * 
     * @type {MatchesV4DataTeamPremierRosterCustomization}
     * @memberof MatchesV4DataTeamPremierRoster
     */
    'customization': MatchesV4DataTeamPremierRosterCustomization;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRoster
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchesV4DataTeamPremierRoster
     */
    'members': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRoster
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRoster
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataTeamPremierRosterCustomization
 */
export interface MatchesV4DataTeamPremierRosterCustomization {
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRosterCustomization
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRosterCustomization
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRosterCustomization
     */
    'primary_color': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRosterCustomization
     */
    'secondary_color': string;
    /**
     * 
     * @type {string}
     * @memberof MatchesV4DataTeamPremierRosterCustomization
     */
    'tertiary_color': string;
}
/**
 * 
 * @export
 * @interface MatchesV4DataTeamRounds
 */
export interface MatchesV4DataTeamRounds {
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataTeamRounds
     */
    'lost': number;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4DataTeamRounds
     */
    'won': number;
}
/**
 * 
 * @export
 * @interface MatchesV4HistoryResponse
 */
export interface MatchesV4HistoryResponse {
    /**
     * 
     * @type {Array<MatchesV4Data>}
     * @memberof MatchesV4HistoryResponse
     */
    'data': Array<MatchesV4Data>;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4HistoryResponse
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface MatchesV4Response
 */
export interface MatchesV4Response {
    /**
     * 
     * @type {MatchesV4Data}
     * @memberof MatchesV4Response
     */
    'data': MatchesV4Data;
    /**
     * 
     * @type {number}
     * @memberof MatchesV4Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'after': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'before': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'returned': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface PremierSearchResponse
 */
export interface PremierSearchResponse {
    /**
     * 
     * @type {Array<PremierTeamLiteResponseData>}
     * @memberof PremierSearchResponse
     */
    'data': Array<PremierTeamLiteResponseData>;
    /**
     * 
     * @type {number}
     * @memberof PremierSearchResponse
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface PremierTeamGamesLeagueString
 */
export interface PremierTeamGamesLeagueString {
    /**
     * 
     * @type {string}
     * @memberof PremierTeamGamesLeagueString
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamGamesLeagueString
     */
    'points_after': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamGamesLeagueString
     */
    'points_before': number;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamGamesLeagueString
     */
    'started_at': string;
}
/**
 * 
 * @export
 * @interface PremierTeamGamesTournament
 */
export interface PremierTeamGamesTournament {
    /**
     * 
     * @type {Array<string>}
     * @memberof PremierTeamGamesTournament
     */
    'matches': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamGamesTournament
     */
    'placement': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamGamesTournament
     */
    'placement_league_bonus': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamGamesTournament
     */
    'points_after': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamGamesTournament
     */
    'points_before': number;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamGamesTournament
     */
    'tournament_id': string;
}
/**
 * 
 * @export
 * @interface PremierTeamHistoryV1Response
 */
export interface PremierTeamHistoryV1Response {
    /**
     * 
     * @type {PremierTeamHistoryV1ResponseData}
     * @memberof PremierTeamHistoryV1Response
     */
    'data': PremierTeamHistoryV1ResponseData;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamHistoryV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface PremierTeamHistoryV1ResponseData
 */
export interface PremierTeamHistoryV1ResponseData {
    /**
     * 
     * @type {Array<PremierTeamGamesLeagueString>}
     * @memberof PremierTeamHistoryV1ResponseData
     */
    'league_matches': Array<PremierTeamGamesLeagueString>;
    /**
     * 
     * @type {Array<PremierTeamGamesTournament>}
     * @memberof PremierTeamHistoryV1ResponseData
     */
    'tournament_matches': Array<PremierTeamGamesTournament>;
}
/**
 * 
 * @export
 * @interface PremierTeamLiteResponseData
 */
export interface PremierTeamLiteResponseData {
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'affinity': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'conference': string;
    /**
     * 
     * @type {PremierTeamV1ResponseDataCustomization}
     * @memberof PremierTeamLiteResponseData
     */
    'customization': PremierTeamV1ResponseDataCustomization;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamLiteResponseData
     */
    'division': number;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamLiteResponseData
     */
    'losses': number;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamLiteResponseData
     */
    'ranking': number;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamLiteResponseData
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamLiteResponseData
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamLiteResponseData
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface PremierTeamMember
 */
export interface PremierTeamMember {
    /**
     * 
     * @type {string}
     * @memberof PremierTeamMember
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamMember
     */
    'puuid': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamMember
     */
    'tag'?: string | null;
}
/**
 * 
 * @export
 * @interface PremierTeamV1Response
 */
export interface PremierTeamV1Response {
    /**
     * 
     * @type {PremierTeamV1ResponseData}
     * @memberof PremierTeamV1Response
     */
    'data': PremierTeamV1ResponseData;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface PremierTeamV1ResponseData
 */
export interface PremierTeamV1ResponseData {
    /**
     * 
     * @type {PremierTeamV1ResponseDataCustomization}
     * @memberof PremierTeamV1ResponseData
     */
    'customization': PremierTeamV1ResponseDataCustomization;
    /**
     * 
     * @type {boolean}
     * @memberof PremierTeamV1ResponseData
     */
    'enrolled': boolean;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseData
     */
    'id': string;
    /**
     * 
     * @type {Array<PremierTeamMember>}
     * @memberof PremierTeamV1ResponseData
     */
    'member': Array<PremierTeamMember>;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseData
     */
    'name': string;
    /**
     * 
     * @type {PremierTeamV1ResponseDataPlacement}
     * @memberof PremierTeamV1ResponseData
     */
    'placement': PremierTeamV1ResponseDataPlacement;
    /**
     * 
     * @type {PremierTeamV1ResponseDataStats}
     * @memberof PremierTeamV1ResponseData
     */
    'stats': PremierTeamV1ResponseDataStats;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseData
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface PremierTeamV1ResponseDataCustomization
 */
export interface PremierTeamV1ResponseDataCustomization {
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseDataCustomization
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseDataCustomization
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseDataCustomization
     */
    'primary': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseDataCustomization
     */
    'secondary': string;
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseDataCustomization
     */
    'tertiary': string;
}
/**
 * 
 * @export
 * @interface PremierTeamV1ResponseDataPlacement
 */
export interface PremierTeamV1ResponseDataPlacement {
    /**
     * 
     * @type {string}
     * @memberof PremierTeamV1ResponseDataPlacement
     */
    'conference': string;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataPlacement
     */
    'division': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataPlacement
     */
    'place': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataPlacement
     */
    'points': number;
}
/**
 * 
 * @export
 * @interface PremierTeamV1ResponseDataStats
 */
export interface PremierTeamV1ResponseDataStats {
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataStats
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataStats
     */
    'matches': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataStats
     */
    'rounds_lost': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataStats
     */
    'rounds_won': number;
    /**
     * 
     * @type {number}
     * @memberof PremierTeamV1ResponseDataStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface QueueStatusV1
 */
export interface QueueStatusV1 {
    /**
     * 
     * @type {Array<QueueStatusV1Data>}
     * @memberof QueueStatusV1
     */
    'data': Array<QueueStatusV1Data>;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface QueueStatusV1Data
 */
export interface QueueStatusV1Data {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1Data
     */
    'enabled': boolean;
    /**
     * 
     * @type {QueueStatusV1GameRules}
     * @memberof QueueStatusV1Data
     */
    'game_rules': QueueStatusV1GameRules;
    /**
     * 
     * @type {QueueStatusV1HighSkill}
     * @memberof QueueStatusV1Data
     */
    'high_skill': QueueStatusV1HighSkill;
    /**
     * 
     * @type {Array<QueueStatusV1Maps>}
     * @memberof QueueStatusV1Data
     */
    'maps': Array<QueueStatusV1Maps>;
    /**
     * 
     * @type {string}
     * @memberof QueueStatusV1Data
     */
    'mode': string;
    /**
     * 
     * @type {string}
     * @memberof QueueStatusV1Data
     */
    'mode_id': string;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1Data
     */
    'number_of_teams': number;
    /**
     * 
     * @type {QueueStatusV1PartySize}
     * @memberof QueueStatusV1Data
     */
    'party_size': QueueStatusV1PartySize;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueueStatusV1Data
     */
    'platforms': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1Data
     */
    'ranked': boolean;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1Data
     */
    'required_account_level': number;
    /**
     * 
     * @type {Array<QueueStatusV1SkillDisparity>}
     * @memberof QueueStatusV1Data
     */
    'skill_disparity': Array<QueueStatusV1SkillDisparity>;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1Data
     */
    'team_size': number;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1Data
     */
    'tournament': boolean;
}
/**
 * 
 * @export
 * @interface QueueStatusV1GameRules
 */
export interface QueueStatusV1GameRules {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'allow_drop_out': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'allow_lenient_surrender': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'allow_overtime_draw_vote': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'assign_random_agents': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'overtime_win_by_two': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'overtime_win_by_two_capped': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'premier_mode': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1GameRules
     */
    'skip_pregame': boolean;
}
/**
 * 
 * @export
 * @interface QueueStatusV1HighSkill
 */
export interface QueueStatusV1HighSkill {
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1HighSkill
     */
    'max_party_size': number;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1HighSkill
     */
    'max_tier': number;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1HighSkill
     */
    'min_tier': number;
}
/**
 * 
 * @export
 * @interface QueueStatusV1IDNamePair
 */
export interface QueueStatusV1IDNamePair {
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1IDNamePair
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof QueueStatusV1IDNamePair
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface QueueStatusV1Map
 */
export interface QueueStatusV1Map {
    /**
     * 
     * @type {string}
     * @memberof QueueStatusV1Map
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QueueStatusV1Map
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface QueueStatusV1Maps
 */
export interface QueueStatusV1Maps {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1Maps
     */
    'enabled': boolean;
    /**
     * 
     * @type {QueueStatusV1Map}
     * @memberof QueueStatusV1Maps
     */
    'map': QueueStatusV1Map;
}
/**
 * 
 * @export
 * @interface QueueStatusV1PartySize
 */
export interface QueueStatusV1PartySize {
    /**
     * 
     * @type {boolean}
     * @memberof QueueStatusV1PartySize
     */
    'full_party_bypass': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof QueueStatusV1PartySize
     */
    'invalid': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1PartySize
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1PartySize
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface QueueStatusV1SkillDisparity
 */
export interface QueueStatusV1SkillDisparity {
    /**
     * 
     * @type {QueueStatusV1IDNamePair}
     * @memberof QueueStatusV1SkillDisparity
     */
    'max_tier': QueueStatusV1IDNamePair;
    /**
     * 
     * @type {string}
     * @memberof QueueStatusV1SkillDisparity
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof QueueStatusV1SkillDisparity
     */
    'tier': number;
}
/**
 * 
 * @export
 * @interface RawV1ErrorData
 */
export interface RawV1ErrorData {
    /**
     * 
     * @type {number}
     * @memberof RawV1ErrorData
     */
    'code': number;
    /**
     * 
     * @type {boolean}
     * @memberof RawV1ErrorData
     */
    'error': boolean;
    /**
     * 
     * @type {string}
     * @memberof RawV1ErrorData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RawV1Payload
 */
export interface RawV1Payload {
    /**
     * 
     * @type {string}
     * @memberof RawV1Payload
     */
    'platform'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RawV1Payload
     */
    'queries'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RawV1Payload
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof RawV1Payload
     */
    'type': string;
    /**
     * 
     * @type {RawV1PayloadValues}
     * @memberof RawV1Payload
     */
    'value': RawV1PayloadValues;
}
/**
 * @type RawV1PayloadValues
 * @export
 */
export type RawV1PayloadValues = Array<string> | string;

/**
 * 
 * @export
 * @interface RawV1Response
 */
export interface RawV1Response {
    /**
     * 
     * @type {RawV1ResponseData}
     * @memberof RawV1Response
     */
    'data': RawV1ResponseData | null;
    /**
     * 
     * @type {number}
     * @memberof RawV1Response
     */
    'status': number;
}
/**
 * @type RawV1ResponseData
 * @export
 */
export type RawV1ResponseData = Array<any> | RawV1ErrorData;

/**
 * 
 * @export
 * @interface SeasonIdShortCombo
 */
export interface SeasonIdShortCombo {
    /**
     * 
     * @type {string}
     * @memberof SeasonIdShortCombo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SeasonIdShortCombo
     */
    'short': string;
}
/**
 * 
 * @export
 * @interface SendError
 */
export interface SendError {
    /**
     * 
     * @type {Array<APIError>}
     * @memberof SendError
     */
    'errors': Array<APIError>;
}
/**
 * 
 * @export
 * @interface StatusIncident
 */
export interface StatusIncident {
    /**
     * 
     * @type {string}
     * @memberof StatusIncident
     */
    'archive_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StatusIncident
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof StatusIncident
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StatusIncident
     */
    'incident_severity': string;
    /**
     * 
     * @type {string}
     * @memberof StatusIncident
     */
    'maintenance_status'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusIncident
     */
    'platforms': Array<string>;
    /**
     * 
     * @type {Array<StatusIncidentContent>}
     * @memberof StatusIncident
     */
    'titles': Array<StatusIncidentContent>;
    /**
     * 
     * @type {string}
     * @memberof StatusIncident
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<StatusIncidentUpdate>}
     * @memberof StatusIncident
     */
    'updates': Array<StatusIncidentUpdate>;
}
/**
 * 
 * @export
 * @interface StatusIncidentContent
 */
export interface StatusIncidentContent {
    /**
     * 
     * @type {string}
     * @memberof StatusIncidentContent
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof StatusIncidentContent
     */
    'locale': string;
}
/**
 * 
 * @export
 * @interface StatusIncidentUpdate
 */
export interface StatusIncidentUpdate {
    /**
     * 
     * @type {string}
     * @memberof StatusIncidentUpdate
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof StatusIncidentUpdate
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof StatusIncidentUpdate
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof StatusIncidentUpdate
     */
    'publish': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusIncidentUpdate
     */
    'publish_locations': Array<string>;
    /**
     * 
     * @type {Array<StatusIncidentContent>}
     * @memberof StatusIncidentUpdate
     */
    'translations': Array<StatusIncidentContent>;
    /**
     * 
     * @type {string}
     * @memberof StatusIncidentUpdate
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface StatusV1
 */
export interface StatusV1 {
    /**
     * 
     * @type {StatusV1Data}
     * @memberof StatusV1
     */
    'data': StatusV1Data;
    /**
     * 
     * @type {number}
     * @memberof StatusV1
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface StatusV1Data
 */
export interface StatusV1Data {
    /**
     * 
     * @type {Array<StatusIncident>}
     * @memberof StatusV1Data
     */
    'incidents': Array<StatusIncident>;
    /**
     * 
     * @type {Array<StatusIncident>}
     * @memberof StatusV1Data
     */
    'maintenances': Array<StatusIncident>;
}
/**
 * 
 * @export
 * @interface StoreFeaturedV1
 */
export interface StoreFeaturedV1 {
    /**
     * 
     * @type {FeaturedBundle}
     * @memberof StoreFeaturedV1
     */
    'FeaturedBundle': FeaturedBundle;
}
/**
 * 
 * @export
 * @interface StoreOffersV1
 */
export interface StoreOffersV1 {
    /**
     * 
     * @type {Array<StoreOffersV1Offer>}
     * @memberof StoreOffersV1
     */
    'Offers': Array<StoreOffersV1Offer>;
    /**
     * 
     * @type {Array<StoreOffersV1UpgradeCurrency>}
     * @memberof StoreOffersV1
     */
    'UpgradeCurrencyOffers': Array<StoreOffersV1UpgradeCurrency>;
}
/**
 * 
 * @export
 * @interface StoreOffersV1Offer
 */
export interface StoreOffersV1Offer {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof StoreOffersV1Offer
     */
    'Cost': { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof StoreOffersV1Offer
     */
    'IsDirectPurchase': boolean;
    /**
     * 
     * @type {string}
     * @memberof StoreOffersV1Offer
     */
    'OfferID': string;
    /**
     * 
     * @type {Array<StoreOffersV1Reward>}
     * @memberof StoreOffersV1Offer
     */
    'Rewards': Array<StoreOffersV1Reward>;
    /**
     * 
     * @type {string}
     * @memberof StoreOffersV1Offer
     */
    'StartDate': string;
}
/**
 * 
 * @export
 * @interface StoreOffersV1Response
 */
export interface StoreOffersV1Response {
    /**
     * 
     * @type {StoreOffersV1}
     * @memberof StoreOffersV1Response
     */
    'data': StoreOffersV1;
    /**
     * 
     * @type {number}
     * @memberof StoreOffersV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface StoreOffersV1Reward
 */
export interface StoreOffersV1Reward {
    /**
     * 
     * @type {string}
     * @memberof StoreOffersV1Reward
     */
    'ItemID': string;
    /**
     * 
     * @type {string}
     * @memberof StoreOffersV1Reward
     */
    'ItemTypeID': string;
    /**
     * 
     * @type {number}
     * @memberof StoreOffersV1Reward
     */
    'Quantity': number;
}
/**
 * 
 * @export
 * @interface StoreOffersV1UpgradeCurrency
 */
export interface StoreOffersV1UpgradeCurrency {
    /**
     * 
     * @type {number}
     * @memberof StoreOffersV1UpgradeCurrency
     */
    'DiscountedPercent': number;
    /**
     * 
     * @type {StoreOffersV1Offer}
     * @memberof StoreOffersV1UpgradeCurrency
     */
    'Offer': StoreOffersV1Offer;
    /**
     * 
     * @type {string}
     * @memberof StoreOffersV1UpgradeCurrency
     */
    'OfferID': string;
    /**
     * 
     * @type {string}
     * @memberof StoreOffersV1UpgradeCurrency
     */
    'StorefrontItemID': string;
}
/**
 * 
 * @export
 * @interface StoredMMR
 */
export interface StoredMMR {
    /**
     * 
     * @type {string}
     * @memberof StoredMMR
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof StoredMMR
     */
    'elo': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMMR
     */
    'last_mmr_change': number;
    /**
     * 
     * @type {StoredMMRMap}
     * @memberof StoredMMR
     */
    'map': StoredMMRMap;
    /**
     * 
     * @type {string}
     * @memberof StoredMMR
     */
    'match_id': string;
    /**
     * 
     * @type {number}
     * @memberof StoredMMR
     */
    'ranking_in_tier': number;
    /**
     * 
     * @type {StoredMMRSeason}
     * @memberof StoredMMR
     */
    'season': StoredMMRSeason;
    /**
     * 
     * @type {StoredMMRTier}
     * @memberof StoredMMR
     */
    'tier': StoredMMRTier;
}
/**
 * 
 * @export
 * @interface StoredMMRMap
 */
export interface StoredMMRMap {
    /**
     * 
     * @type {string}
     * @memberof StoredMMRMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMMRMap
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StoredMMRResponse
 */
export interface StoredMMRResponse {
    /**
     * 
     * @type {Array<StoredMMR>}
     * @memberof StoredMMRResponse
     */
    'data': Array<StoredMMR>;
    /**
     * 
     * @type {Pagination}
     * @memberof StoredMMRResponse
     */
    'results': Pagination;
    /**
     * 
     * @type {number}
     * @memberof StoredMMRResponse
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface StoredMMRSeason
 */
export interface StoredMMRSeason {
    /**
     * 
     * @type {string}
     * @memberof StoredMMRSeason
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMMRSeason
     */
    'short': string;
}
/**
 * 
 * @export
 * @interface StoredMMRTier
 */
export interface StoredMMRTier {
    /**
     * 
     * @type {number}
     * @memberof StoredMMRTier
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StoredMMRTier
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StoredMMRV2
 */
export interface StoredMMRV2 {
    /**
     * 
     * @type {string}
     * @memberof StoredMMRV2
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof StoredMMRV2
     */
    'elo': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMMRV2
     */
    'last_change': number;
    /**
     * 
     * @type {MapIdNameCombo}
     * @memberof StoredMMRV2
     */
    'map': MapIdNameCombo;
    /**
     * 
     * @type {string}
     * @memberof StoredMMRV2
     */
    'match_id': string;
    /**
     * 
     * @type {number}
     * @memberof StoredMMRV2
     */
    'refunded_rr': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMMRV2
     */
    'rr': number;
    /**
     * 
     * @type {SeasonIdShortCombo}
     * @memberof StoredMMRV2
     */
    'season': SeasonIdShortCombo;
    /**
     * 
     * @type {TierIdNameCombo}
     * @memberof StoredMMRV2
     */
    'tier': TierIdNameCombo;
    /**
     * 
     * @type {boolean}
     * @memberof StoredMMRV2
     */
    'was_derank_protected': boolean;
}
/**
 * 
 * @export
 * @interface StoredMMRV2Response
 */
export interface StoredMMRV2Response {
    /**
     * 
     * @type {Array<StoredMMRV2>}
     * @memberof StoredMMRV2Response
     */
    'data': Array<StoredMMRV2>;
    /**
     * 
     * @type {Pagination}
     * @memberof StoredMMRV2Response
     */
    'results': Pagination;
    /**
     * 
     * @type {number}
     * @memberof StoredMMRV2Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface StoredMatch
 */
export interface StoredMatch {
    /**
     * 
     * @type {StoredMatchMeta}
     * @memberof StoredMatch
     */
    'meta': StoredMatchMeta;
    /**
     * 
     * @type {StoredMatchStats}
     * @memberof StoredMatch
     */
    'stats': StoredMatchStats;
    /**
     * 
     * @type {StoredMatchTeam}
     * @memberof StoredMatch
     */
    'teams': StoredMatchTeam;
}
/**
 * 
 * @export
 * @interface StoredMatchMeta
 */
export interface StoredMatchMeta {
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMeta
     */
    'cluster'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMeta
     */
    'id': string;
    /**
     * 
     * @type {StoredMatchMetaMap}
     * @memberof StoredMatchMeta
     */
    'map': StoredMatchMetaMap;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMeta
     */
    'mode': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMeta
     */
    'region': string;
    /**
     * 
     * @type {StoredMatchMetaSeason}
     * @memberof StoredMatchMeta
     */
    'season': StoredMatchMetaSeason;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMeta
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMeta
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface StoredMatchMetaMap
 */
export interface StoredMatchMetaMap {
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMetaMap
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMetaMap
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StoredMatchMetaSeason
 */
export interface StoredMatchMetaSeason {
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMetaSeason
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchMetaSeason
     */
    'short': string;
}
/**
 * 
 * @export
 * @interface StoredMatchStats
 */
export interface StoredMatchStats {
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStats
     */
    'assists': number;
    /**
     * 
     * @type {StoredMatchStatsCharacter}
     * @memberof StoredMatchStats
     */
    'character': StoredMatchStatsCharacter;
    /**
     * 
     * @type {StoredMatchStatsDamage}
     * @memberof StoredMatchStats
     */
    'damage': StoredMatchStatsDamage;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStats
     */
    'deaths': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStats
     */
    'kills': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStats
     */
    'level': number;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchStats
     */
    'puuid': string;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStats
     */
    'score': number;
    /**
     * 
     * @type {StoredMatchStatsShots}
     * @memberof StoredMatchStats
     */
    'shots': StoredMatchStatsShots;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchStats
     */
    'team': string;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStats
     */
    'tier': number;
}
/**
 * 
 * @export
 * @interface StoredMatchStatsCharacter
 */
export interface StoredMatchStatsCharacter {
    /**
     * 
     * @type {string}
     * @memberof StoredMatchStatsCharacter
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoredMatchStatsCharacter
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StoredMatchStatsDamage
 */
export interface StoredMatchStatsDamage {
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStatsDamage
     */
    'made': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStatsDamage
     */
    'received': number;
}
/**
 * 
 * @export
 * @interface StoredMatchStatsShots
 */
export interface StoredMatchStatsShots {
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStatsShots
     */
    'body': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStatsShots
     */
    'head': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchStatsShots
     */
    'leg': number;
}
/**
 * 
 * @export
 * @interface StoredMatchTeam
 */
export interface StoredMatchTeam {
    /**
     * 
     * @type {number}
     * @memberof StoredMatchTeam
     */
    'blue': number;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchTeam
     */
    'red': number;
}
/**
 * 
 * @export
 * @interface StoredMatchesResponse
 */
export interface StoredMatchesResponse {
    /**
     * 
     * @type {Array<StoredMatch>}
     * @memberof StoredMatchesResponse
     */
    'data': Array<StoredMatch>;
    /**
     * 
     * @type {Pagination}
     * @memberof StoredMatchesResponse
     */
    'results': Pagination;
    /**
     * 
     * @type {number}
     * @memberof StoredMatchesResponse
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface TierIdNameCombo
 */
export interface TierIdNameCombo {
    /**
     * 
     * @type {number}
     * @memberof TierIdNameCombo
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TierIdNameCombo
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface VersionV1Data
 */
export interface VersionV1Data {
    /**
     * 
     * @type {string}
     * @memberof VersionV1Data
     */
    'branch': string;
    /**
     * 
     * @type {string}
     * @memberof VersionV1Data
     */
    'build_date': string;
    /**
     * 
     * @type {string}
     * @memberof VersionV1Data
     */
    'build_ver': string;
    /**
     * 
     * @type {string}
     * @memberof VersionV1Data
     */
    'last_checked': string;
    /**
     * 
     * @type {string}
     * @memberof VersionV1Data
     */
    'region': string;
    /**
     * 
     * @type {number}
     * @memberof VersionV1Data
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof VersionV1Data
     */
    'version_for_api': string;
}
/**
 * 
 * @export
 * @interface VersionV1Response
 */
export interface VersionV1Response {
    /**
     * 
     * @type {VersionV1Data}
     * @memberof VersionV1Response
     */
    'data': VersionV1Data;
    /**
     * 
     * @type {number}
     * @memberof VersionV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface WebsiteByIdV1Data
 */
export interface WebsiteByIdV1Data {
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'banner_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'content'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'external_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteByIdV1Data
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebsiteByIdV1Response
 */
export interface WebsiteByIdV1Response {
    /**
     * 
     * @type {WebsiteByIdV1Data}
     * @memberof WebsiteByIdV1Response
     */
    'data': WebsiteByIdV1Data;
    /**
     * 
     * @type {number}
     * @memberof WebsiteByIdV1Response
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface WebsiteV1Data
 */
export interface WebsiteV1Data {
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'banner_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'external_link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteV1Data
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebsiteV1Response
 */
export interface WebsiteV1Response {
    /**
     * 
     * @type {Array<WebsiteV1Data>}
     * @memberof WebsiteV1Response
     */
    'data': Array<WebsiteV1Data>;
    /**
     * 
     * @type {number}
     * @memberof WebsiteV1Response
     */
    'status': number;
}

/**
 * ValorantApi - axios parameter creator
 * @export
 */
export const ValorantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] Crosshair code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crosshair: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/crosshair/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [region] Region filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        esportsSchedulesV1: async (region?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/esports/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV1: async (puuid: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getAccountByIdV1', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/account/{puuid}`
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV2: async (puuid: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getAccountByIdV2', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/account/{puuid}`
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1: async (name: string, tag: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getAccountV1', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getAccountV1', 'tag', tag)
            const localVarPath = `/valorant/v1/account/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2: async (name: string, tag: string, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getAccountV2', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getAccountV2', 'tag', tag)
            const localVarPath = `/valorant/v2/account/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [locale] Locale code (e.g., en-US, de-DE) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentV1: async (locale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ById: async (affinity: string, puuid: string, mode?: string, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV3ById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMatchesV3ById', 'puuid', puuid)
            const localVarPath = `/valorant/v3/by-puuid/matches/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {MatchMode} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ByName: async (affinity: string, name: string, tag: string, mode?: MatchMode, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV3ByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMatchesV3ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMatchesV3ByName', 'tag', tag)
            const localVarPath = `/valorant/v3/matches/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ById: async (affinity: string, platform: string, puuid: string, mode?: string, map?: string, size?: number, start?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV4ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMatchesV4ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMatchesV4ById', 'puuid', puuid)
            const localVarPath = `/valorant/v4/by-puuid/matches/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ByName: async (affinity: string, platform: string, name: string, tag: string, mode?: string, map?: string, size?: number, start?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMatchesV4ByName', 'tag', tag)
            const localVarPath = `/valorant/v4/matches/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryById: async (affinity: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrHistoryById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/mmr-history/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryByName: async (affinity: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrHistoryByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrHistoryByName', 'tag', tag)
            const localVarPath = `/valorant/v1/mmr-history/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ById: async (affinity: string, platform: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryV2ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrHistoryV2ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrHistoryV2ById', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/mmr-history/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ByName: async (affinity: string, platform: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrHistoryV2ByName', 'tag', tag)
            const localVarPath = `/valorant/v2/mmr-history/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ById: async (affinity: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV1ById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrV1ById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/mmr/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ByName: async (affinity: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV1ByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrV1ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrV1ByName', 'tag', tag)
            const localVarPath = `/valorant/v1/mmr/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ById: async (affinity: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV2ById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrV2ById', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/mmr/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ByName: async (affinity: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV2ByName', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrV2ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrV2ByName', 'tag', tag)
            const localVarPath = `/valorant/v2/mmr/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ById: async (affinity: string, platform: string, puuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV3ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrV3ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('getMmrV3ById', 'puuid', puuid)
            const localVarPath = `/valorant/v3/by-puuid/mmr/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ByName: async (affinity: string, platform: string, name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('getMmrV3ByName', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('getMmrV3ByName', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMmrV3ByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getMmrV3ByName', 'tag', tag)
            const localVarPath = `/valorant/v3/mmr/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV1: async (affinity: string, season?: string, name?: string, tag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('leaderboardV1', 'affinity', affinity)
            const localVarPath = `/valorant/v1/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {string} [puuid] Player UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV2: async (affinity: string, season?: string, name?: string, tag?: string, puuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('leaderboardV2', 'affinity', affinity)
            const localVarPath = `/valorant/v2/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (puuid !== undefined) {
                localVarQueryParameter['puuid'] = puuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} [season] Season ID (optional)
         * @param {number} [size] Number of results per page (optional)
         * @param {number} [page] Page number (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV3: async (affinity: string, platform: string, season?: string, size?: number, page?: number, name?: string, tag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('leaderboardV3', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('leaderboardV3', 'platform', platform)
            const localVarPath = `/valorant/v3/leaderboard/{affinity}/{platform}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV2: async (matchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV2', 'matchId', matchId)
            const localVarPath = `/valorant/v2/match/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4: async (affinity: string, matchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('matchV4', 'affinity', affinity)
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('matchV4', 'matchId', matchId)
            const localVarPath = `/valorant/v4/match/{affinity}/{match_id}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('premierById', 'id', id)
            const localVarPath = `/valorant/v1/premier/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByIdHistory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('premierByIdHistory', 'id', id)
            const localVarPath = `/valorant/v1/premier/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByName: async (name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('premierByName', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('premierByName', 'tag', tag)
            const localVarPath = `/valorant/v1/premier/{name}/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByNameHistory: async (name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('premierByNameHistory', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('premierByNameHistory', 'tag', tag)
            const localVarPath = `/valorant/v1/premier/{name}/{tag}/history`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [conference] Conference filter (optional)
         * @param {string} [division] Division filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierLeaderboard: async (affinity: string, conference?: string, division?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('premierLeaderboard', 'affinity', affinity)
            const localVarPath = `/valorant/v1/premier/leaderboard/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (conference !== undefined) {
                localVarQueryParameter['conference'] = conference;
            }

            if (division !== undefined) {
                localVarQueryParameter['division'] = division;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] Team name to search for (optional)
         * @param {string} [tag] Team tag to search for (optional)
         * @param {string} [id] Team UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierSearch: async (name?: string, tag?: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/valorant/v1/premier/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueStatus: async (affinity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('queueStatus', 'affinity', affinity)
            const localVarPath = `/valorant/v1/queue-status/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RawV1Payload} rawV1Payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raw: async (rawV1Payload: RawV1Payload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rawV1Payload' is not null or undefined
            assertParamExists('raw', 'rawV1Payload', rawV1Payload)
            const localVarPath = `/valorant/v1/raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rawV1Payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (affinity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('status', 'affinity', affinity)
            const localVarPath = `/valorant/v1/status/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeFeatured: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('storeFeatured', 'version', version)
            const localVarPath = `/valorant/{version}/store-featured`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOffers: async (version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('storeOffers', 'version', version)
            const localVarPath = `/valorant/{version}/store-offers`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatches: async (affinity: string, name: string, tag: string, mode?: string, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMatches', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('storedMatches', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storedMatches', 'tag', tag)
            const localVarPath = `/valorant/v1/stored-matches/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatchesById: async (affinity: string, puuid: string, mode?: string, map?: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMatchesById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('storedMatchesById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/stored-matches/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (map !== undefined) {
                localVarQueryParameter['map'] = map;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistory: async (affinity: string, name: string, tag: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistory', 'affinity', affinity)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('storedMmrHistory', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storedMmrHistory', 'tag', tag)
            const localVarPath = `/valorant/v1/stored-mmr-history/{affinity}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryById: async (affinity: string, puuid: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistoryById', 'affinity', affinity)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('storedMmrHistoryById', 'puuid', puuid)
            const localVarPath = `/valorant/v1/by-puuid/stored-mmr-history/{affinity}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2: async (affinity: string, platform: string, name: string, tag: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'platform', platform)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storedMmrHistoryV2', 'tag', tag)
            const localVarPath = `/valorant/v2/stored-mmr-history/{affinity}/{platform}/{name}/{tag}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2ById: async (affinity: string, platform: string, puuid: string, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('storedMmrHistoryV2ById', 'affinity', affinity)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('storedMmrHistoryV2ById', 'platform', platform)
            // verify required parameter 'puuid' is not null or undefined
            assertParamExists('storedMmrHistoryV2ById', 'puuid', puuid)
            const localVarPath = `/valorant/v2/by-puuid/stored-mmr-history/{affinity}/{platform}/{puuid}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)))
                .replace(`{${"platform"}}`, encodeURIComponent(String(platform)))
                .replace(`{${"puuid"}}`, encodeURIComponent(String(puuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: async (affinity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'affinity' is not null or undefined
            assertParamExists('version', 'affinity', affinity)
            const localVarPath = `/valorant/v1/version/{affinity}`
                .replace(`{${"affinity"}}`, encodeURIComponent(String(affinity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {string} [category] Category filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        website: async (countryCode: string, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('website', 'countryCode', countryCode)
            const localVarPath = `/valorant/v1/website/{country_code}`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dbId Database ID of the website entry
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteById: async (dbId: string, countryCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbId' is not null or undefined
            assertParamExists('websiteById', 'dbId', dbId)
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('websiteById', 'countryCode', countryCode)
            const localVarPath = `/valorant/v1/website/{country_code}/{db_id}`
                .replace(`{${"db_id"}}`, encodeURIComponent(String(dbId)))
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValorantApi - functional programming interface
 * @export
 */
export const ValorantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValorantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] Crosshair code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crosshair(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crosshair(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.crosshair']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [region] Region filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async esportsSchedulesV1(region?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EsportsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.esportsSchedulesV1(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.esportsSchedulesV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByIdV1(puuid: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByIdV1(puuid, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountByIdV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} puuid Player UUID
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByIdV2(puuid: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByIdV2(puuid, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountByIdV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV1(name: string, tag: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV1(name, tag, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {boolean} [force] Bypass cache and refresh (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountV2(name: string, tag: string, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountV2(name, tag, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getAccountV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [locale] Locale code (e.g., en-US, de-DE) - optional
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentV1(locale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentV1(locale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getContentV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV3ById(affinity: string, puuid: string, mode?: string, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV3ListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV3ById(affinity, puuid, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV3ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {MatchMode} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV3ByName(affinity: string, name: string, tag: string, mode?: MatchMode, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV3ListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV3ByName(affinity, name, tag, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV3ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV4ById(affinity: string, platform: string, puuid: string, mode?: string, map?: string, size?: number, start?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV4HistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV4ById(affinity, platform, puuid, mode, map, size, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV4ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {number} [start] Start index for pagination (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchesV4ByName(affinity: string, platform: string, name: string, tag: string, mode?: string, map?: string, size?: number, start?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV4HistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatchesV4ByName(affinity, platform, name, tag, mode, map, size, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMatchesV4ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryById(affinity: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryById(affinity, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryByName(affinity: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryByName(affinity, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryV2ById(affinity: string, platform: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryV2ById(affinity, platform, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryV2ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrHistoryV2ByName(affinity: string, platform: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRHistoryV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrHistoryV2ByName(affinity, platform, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrHistoryV2ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV1ById(affinity: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV1ById(affinity, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV1ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV1ByName(affinity: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV1ByName(affinity, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV1ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV2ById(affinity: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV2ById(affinity, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV2ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV2ByName(affinity: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV2ByName(affinity, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV2ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV3ById(affinity: string, platform: string, puuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV3ById(affinity, platform, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV3ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMmrV3ByName(affinity: string, platform: string, name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MMRV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMmrV3ByName(affinity, platform, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.getMmrV3ByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardV1(affinity: string, season?: string, name?: string, tag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardV1(affinity, season, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.leaderboardV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [season] Season ID (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {string} [puuid] Player UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardV2(affinity: string, season?: string, name?: string, tag?: string, puuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardV2(affinity, season, name, tag, puuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.leaderboardV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} [season] Season ID (optional)
         * @param {number} [size] Number of results per page (optional)
         * @param {number} [page] Page number (optional)
         * @param {string} [name] Player name to search for (optional)
         * @param {string} [tag] Player tag to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardV3(affinity: string, platform: string, season?: string, size?: number, page?: number, name?: string, tag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardV3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardV3(affinity, platform, season, size, page, name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.leaderboardV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV2(matchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV2(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.matchV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} matchId Match UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchV4(affinity: string, matchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchesV4Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchV4(affinity, matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.matchV4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id Team UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierByIdHistory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierByIdHistory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierByIdHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierByName(name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierByName(name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name Team name
         * @param {string} tag Team tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierByNameHistory(name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierTeamHistoryV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierByNameHistory(name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierByNameHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} [conference] Conference filter (optional)
         * @param {string} [division] Division filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierLeaderboard(affinity: string, conference?: string, division?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierLeaderboard(affinity, conference, division, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [name] Team name to search for (optional)
         * @param {string} [tag] Team tag to search for (optional)
         * @param {string} [id] Team UUID to search for (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async premierSearch(name?: string, tag?: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PremierSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.premierSearch(name, tag, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.premierSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueStatus(affinity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueStatusV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueStatus(affinity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.queueStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RawV1Payload} rawV1Payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async raw(rawV1Payload: RawV1Payload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RawV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.raw(rawV1Payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.raw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(affinity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(affinity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.status']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeFeatured(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreFeaturedV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeFeatured(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storeFeatured']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} version API version (v1, v2)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeOffers(version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreOffersV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeOffers(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storeOffers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMatches(affinity: string, name: string, tag: string, mode?: string, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMatchesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMatches(affinity, name, tag, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {string} [mode] Game mode filter (optional)
         * @param {string} [map] Map filter (optional)
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMatchesById(affinity: string, puuid: string, mode?: string, map?: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMatchesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMatchesById(affinity, puuid, mode, map, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMatchesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistory(affinity: string, name: string, tag: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistory(affinity, name, tag, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistoryById(affinity: string, puuid: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistoryById(affinity, puuid, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} name Riot ID name
         * @param {string} tag Riot ID tag
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistoryV2(affinity: string, platform: string, name: string, tag: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistoryV2(affinity, platform, name, tag, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistoryV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {string} platform Platform (pc, console)
         * @param {string} puuid Player UUID
         * @param {number} [size] Number of results (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storedMmrHistoryV2ById(affinity: string, platform: string, puuid: string, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoredMMRV2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storedMmrHistoryV2ById(affinity, platform, puuid, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.storedMmrHistoryV2ById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} affinity Region/affinity (e.g., na, eu, ap, kr)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async version(affinity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.version(affinity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.version']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {string} [category] Category filter (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async website(countryCode: string, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.website(countryCode, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.website']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} dbId Database ID of the website entry
         * @param {string} countryCode Country code (e.g., en-us, de-de)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteById(dbId: string, countryCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteByIdV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteById(dbId, countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ValorantApi.websiteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ValorantApi - factory interface
 * @export
 */
export const ValorantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValorantApiFp(configuration)
    return {
        /**
         * 
         * @param {ValorantApiCrosshairRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crosshair(requestParameters: ValorantApiCrosshairRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.crosshair(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiEsportsSchedulesV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        esportsSchedulesV1(requestParameters: ValorantApiEsportsSchedulesV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<EsportsV1Response> {
            return localVarFp.esportsSchedulesV1(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountByIdV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV1(requestParameters: ValorantApiGetAccountByIdV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV1Response> {
            return localVarFp.getAccountByIdV1(requestParameters.puuid, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountByIdV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByIdV2(requestParameters: ValorantApiGetAccountByIdV2Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV2Response> {
            return localVarFp.getAccountByIdV2(requestParameters.puuid, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV1(requestParameters: ValorantApiGetAccountV1Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV1Response> {
            return localVarFp.getAccountV1(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetAccountV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountV2(requestParameters: ValorantApiGetAccountV2Request, options?: RawAxiosRequestConfig): AxiosPromise<AccountV2Response> {
            return localVarFp.getAccountV2(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetContentV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentV1(requestParameters: ValorantApiGetContentV1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<ContentV1Response> {
            return localVarFp.getContentV1(requestParameters.locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV3ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ById(requestParameters: ValorantApiGetMatchesV3ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV3ListResponse> {
            return localVarFp.getMatchesV3ById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV3ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV3ByName(requestParameters: ValorantApiGetMatchesV3ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV3ListResponse> {
            return localVarFp.getMatchesV3ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV4ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ById(requestParameters: ValorantApiGetMatchesV4ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV4HistoryResponse> {
            return localVarFp.getMatchesV4ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMatchesV4ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchesV4ByName(requestParameters: ValorantApiGetMatchesV4ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV4HistoryResponse> {
            return localVarFp.getMatchesV4ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryById(requestParameters: ValorantApiGetMmrHistoryByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV1Response> {
            return localVarFp.getMmrHistoryById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryByName(requestParameters: ValorantApiGetMmrHistoryByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV1Response> {
            return localVarFp.getMmrHistoryByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryV2ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ById(requestParameters: ValorantApiGetMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV2Response> {
            return localVarFp.getMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrHistoryV2ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrHistoryV2ByName(requestParameters: ValorantApiGetMmrHistoryV2ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRHistoryV2Response> {
            return localVarFp.getMmrHistoryV2ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV1ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ById(requestParameters: ValorantApiGetMmrV1ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV1Response> {
            return localVarFp.getMmrV1ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV1ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV1ByName(requestParameters: ValorantApiGetMmrV1ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV1Response> {
            return localVarFp.getMmrV1ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV2ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ById(requestParameters: ValorantApiGetMmrV2ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV2Response> {
            return localVarFp.getMmrV2ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV2ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV2ByName(requestParameters: ValorantApiGetMmrV2ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV2Response> {
            return localVarFp.getMmrV2ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV3ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ById(requestParameters: ValorantApiGetMmrV3ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV3Response> {
            return localVarFp.getMmrV3ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiGetMmrV3ByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMmrV3ByName(requestParameters: ValorantApiGetMmrV3ByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<MMRV3Response> {
            return localVarFp.getMmrV3ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiLeaderboardV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV1(requestParameters: ValorantApiLeaderboardV1Request, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.leaderboardV1(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiLeaderboardV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV2(requestParameters: ValorantApiLeaderboardV2Request, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardV2Response> {
            return localVarFp.leaderboardV2(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, requestParameters.puuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiLeaderboardV3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardV3(requestParameters: ValorantApiLeaderboardV3Request, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardV3Response> {
            return localVarFp.leaderboardV3(requestParameters.affinity, requestParameters.platform, requestParameters.season, requestParameters.size, requestParameters.page, requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiMatchV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV2(requestParameters: ValorantApiMatchV2Request, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV2Response> {
            return localVarFp.matchV2(requestParameters.matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiMatchV4Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchV4(requestParameters: ValorantApiMatchV4Request, options?: RawAxiosRequestConfig): AxiosPromise<MatchesV4Response> {
            return localVarFp.matchV4(requestParameters.affinity, requestParameters.matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierById(requestParameters: ValorantApiPremierByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamV1Response> {
            return localVarFp.premierById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByIdHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByIdHistory(requestParameters: ValorantApiPremierByIdHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamV1Response> {
            return localVarFp.premierByIdHistory(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByName(requestParameters: ValorantApiPremierByNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamV1Response> {
            return localVarFp.premierByName(requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierByNameHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierByNameHistory(requestParameters: ValorantApiPremierByNameHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierTeamHistoryV1Response> {
            return localVarFp.premierByNameHistory(requestParameters.name, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierLeaderboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierLeaderboard(requestParameters: ValorantApiPremierLeaderboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<PremierSearchResponse> {
            return localVarFp.premierLeaderboard(requestParameters.affinity, requestParameters.conference, requestParameters.division, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiPremierSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        premierSearch(requestParameters: ValorantApiPremierSearchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PremierSearchResponse> {
            return localVarFp.premierSearch(requestParameters.name, requestParameters.tag, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiQueueStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueStatus(requestParameters: ValorantApiQueueStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueueStatusV1> {
            return localVarFp.queueStatus(requestParameters.affinity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiRawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        raw(requestParameters: ValorantApiRawRequest, options?: RawAxiosRequestConfig): AxiosPromise<RawV1Response> {
            return localVarFp.raw(requestParameters.rawV1Payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(requestParameters: ValorantApiStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<StatusV1> {
            return localVarFp.status(requestParameters.affinity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoreFeaturedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeFeatured(requestParameters: ValorantApiStoreFeaturedRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoreFeaturedV1> {
            return localVarFp.storeFeatured(requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoreOffersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOffers(requestParameters: ValorantApiStoreOffersRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoreOffersV1Response> {
            return localVarFp.storeOffers(requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMatchesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatches(requestParameters: ValorantApiStoredMatchesRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMatchesResponse> {
            return localVarFp.storedMatches(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMatchesByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMatchesById(requestParameters: ValorantApiStoredMatchesByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMatchesResponse> {
            return localVarFp.storedMatchesById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistory(requestParameters: ValorantApiStoredMmrHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRResponse> {
            return localVarFp.storedMmrHistory(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryById(requestParameters: ValorantApiStoredMmrHistoryByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRResponse> {
            return localVarFp.storedMmrHistoryById(requestParameters.affinity, requestParameters.puuid, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2(requestParameters: ValorantApiStoredMmrHistoryV2Request, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRV2Response> {
            return localVarFp.storedMmrHistoryV2(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiStoredMmrHistoryV2ByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storedMmrHistoryV2ById(requestParameters: ValorantApiStoredMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoredMMRV2Response> {
            return localVarFp.storedMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(requestParameters: ValorantApiVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<VersionV1Response> {
            return localVarFp.version(requestParameters.affinity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiWebsiteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        website(requestParameters: ValorantApiWebsiteRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebsiteV1Response> {
            return localVarFp.website(requestParameters.countryCode, requestParameters.category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValorantApiWebsiteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteById(requestParameters: ValorantApiWebsiteByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebsiteByIdV1Response> {
            return localVarFp.websiteById(requestParameters.dbId, requestParameters.countryCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for crosshair operation in ValorantApi.
 * @export
 * @interface ValorantApiCrosshairRequest
 */
export interface ValorantApiCrosshairRequest {
    /**
     * Crosshair code
     * @type {string}
     * @memberof ValorantApiCrosshair
     */
    readonly id?: string
}

/**
 * Request parameters for esportsSchedulesV1 operation in ValorantApi.
 * @export
 * @interface ValorantApiEsportsSchedulesV1Request
 */
export interface ValorantApiEsportsSchedulesV1Request {
    /**
     * Region filter (optional)
     * @type {string}
     * @memberof ValorantApiEsportsSchedulesV1
     */
    readonly region?: string
}

/**
 * Request parameters for getAccountByIdV1 operation in ValorantApi.
 * @export
 * @interface ValorantApiGetAccountByIdV1Request
 */
export interface ValorantApiGetAccountByIdV1Request {
    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetAccountByIdV1
     */
    readonly puuid: string

    /**
     * Bypass cache and refresh (optional)
     * @type {boolean}
     * @memberof ValorantApiGetAccountByIdV1
     */
    readonly force?: boolean
}

/**
 * Request parameters for getAccountByIdV2 operation in ValorantApi.
 * @export
 * @interface ValorantApiGetAccountByIdV2Request
 */
export interface ValorantApiGetAccountByIdV2Request {
    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetAccountByIdV2
     */
    readonly puuid: string

    /**
     * Bypass cache and refresh (optional)
     * @type {boolean}
     * @memberof ValorantApiGetAccountByIdV2
     */
    readonly force?: boolean
}

/**
 * Request parameters for getAccountV1 operation in ValorantApi.
 * @export
 * @interface ValorantApiGetAccountV1Request
 */
export interface ValorantApiGetAccountV1Request {
    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetAccountV1
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetAccountV1
     */
    readonly tag: string

    /**
     * Bypass cache and refresh (optional)
     * @type {boolean}
     * @memberof ValorantApiGetAccountV1
     */
    readonly force?: boolean
}

/**
 * Request parameters for getAccountV2 operation in ValorantApi.
 * @export
 * @interface ValorantApiGetAccountV2Request
 */
export interface ValorantApiGetAccountV2Request {
    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetAccountV2
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetAccountV2
     */
    readonly tag: string

    /**
     * Bypass cache and refresh (optional)
     * @type {boolean}
     * @memberof ValorantApiGetAccountV2
     */
    readonly force?: boolean
}

/**
 * Request parameters for getContentV1 operation in ValorantApi.
 * @export
 * @interface ValorantApiGetContentV1Request
 */
export interface ValorantApiGetContentV1Request {
    /**
     * Locale code (e.g., en-US, de-DE) - optional
     * @type {string}
     * @memberof ValorantApiGetContentV1
     */
    readonly locale?: string
}

/**
 * Request parameters for getMatchesV3ById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMatchesV3ByIdRequest
 */
export interface ValorantApiGetMatchesV3ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ById
     */
    readonly affinity: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ById
     */
    readonly puuid: string

    /**
     * Game mode filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ById
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ById
     */
    readonly map?: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiGetMatchesV3ById
     */
    readonly size?: number
}

/**
 * Request parameters for getMatchesV3ByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMatchesV3ByNameRequest
 */
export interface ValorantApiGetMatchesV3ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ByName
     */
    readonly affinity: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ByName
     */
    readonly tag: string

    /**
     * Game mode filter (optional)
     * @type {MatchMode}
     * @memberof ValorantApiGetMatchesV3ByName
     */
    readonly mode?: MatchMode

    /**
     * Map filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV3ByName
     */
    readonly map?: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiGetMatchesV3ByName
     */
    readonly size?: number
}

/**
 * Request parameters for getMatchesV4ById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMatchesV4ByIdRequest
 */
export interface ValorantApiGetMatchesV4ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly platform: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly puuid: string

    /**
     * Game mode filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly map?: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly size?: number

    /**
     * Start index for pagination (optional)
     * @type {number}
     * @memberof ValorantApiGetMatchesV4ById
     */
    readonly start?: number
}

/**
 * Request parameters for getMatchesV4ByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMatchesV4ByNameRequest
 */
export interface ValorantApiGetMatchesV4ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly platform: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly tag: string

    /**
     * Game mode filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     * @type {string}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly map?: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly size?: number

    /**
     * Start index for pagination (optional)
     * @type {number}
     * @memberof ValorantApiGetMatchesV4ByName
     */
    readonly start?: number
}

/**
 * Request parameters for getMmrHistoryById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrHistoryByIdRequest
 */
export interface ValorantApiGetMmrHistoryByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryById
     */
    readonly affinity: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryById
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrHistoryByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrHistoryByNameRequest
 */
export interface ValorantApiGetMmrHistoryByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryByName
     */
    readonly affinity: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryByName
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrHistoryV2ById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrHistoryV2ByIdRequest
 */
export interface ValorantApiGetMmrHistoryV2ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ById
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ById
     */
    readonly platform: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ById
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrHistoryV2ByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrHistoryV2ByNameRequest
 */
export interface ValorantApiGetMmrHistoryV2ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ByName
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ByName
     */
    readonly platform: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMmrHistoryV2ByName
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrV1ById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrV1ByIdRequest
 */
export interface ValorantApiGetMmrV1ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrV1ById
     */
    readonly affinity: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMmrV1ById
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrV1ByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrV1ByNameRequest
 */
export interface ValorantApiGetMmrV1ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrV1ByName
     */
    readonly affinity: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMmrV1ByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMmrV1ByName
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrV2ById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrV2ByIdRequest
 */
export interface ValorantApiGetMmrV2ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrV2ById
     */
    readonly affinity: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMmrV2ById
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrV2ByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrV2ByNameRequest
 */
export interface ValorantApiGetMmrV2ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrV2ByName
     */
    readonly affinity: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMmrV2ByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMmrV2ByName
     */
    readonly tag: string
}

/**
 * Request parameters for getMmrV3ById operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrV3ByIdRequest
 */
export interface ValorantApiGetMmrV3ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrV3ById
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiGetMmrV3ById
     */
    readonly platform: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiGetMmrV3ById
     */
    readonly puuid: string
}

/**
 * Request parameters for getMmrV3ByName operation in ValorantApi.
 * @export
 * @interface ValorantApiGetMmrV3ByNameRequest
 */
export interface ValorantApiGetMmrV3ByNameRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiGetMmrV3ByName
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiGetMmrV3ByName
     */
    readonly platform: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiGetMmrV3ByName
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiGetMmrV3ByName
     */
    readonly tag: string
}

/**
 * Request parameters for leaderboardV1 operation in ValorantApi.
 * @export
 * @interface ValorantApiLeaderboardV1Request
 */
export interface ValorantApiLeaderboardV1Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiLeaderboardV1
     */
    readonly affinity: string

    /**
     * Season ID (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV1
     */
    readonly season?: string

    /**
     * Player name to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV1
     */
    readonly name?: string

    /**
     * Player tag to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV1
     */
    readonly tag?: string
}

/**
 * Request parameters for leaderboardV2 operation in ValorantApi.
 * @export
 * @interface ValorantApiLeaderboardV2Request
 */
export interface ValorantApiLeaderboardV2Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiLeaderboardV2
     */
    readonly affinity: string

    /**
     * Season ID (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV2
     */
    readonly season?: string

    /**
     * Player name to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV2
     */
    readonly name?: string

    /**
     * Player tag to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV2
     */
    readonly tag?: string

    /**
     * Player UUID to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV2
     */
    readonly puuid?: string
}

/**
 * Request parameters for leaderboardV3 operation in ValorantApi.
 * @export
 * @interface ValorantApiLeaderboardV3Request
 */
export interface ValorantApiLeaderboardV3Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly platform: string

    /**
     * Season ID (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly season?: string

    /**
     * Number of results per page (optional)
     * @type {number}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly size?: number

    /**
     * Page number (optional)
     * @type {number}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly page?: number

    /**
     * Player name to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly name?: string

    /**
     * Player tag to search for (optional)
     * @type {string}
     * @memberof ValorantApiLeaderboardV3
     */
    readonly tag?: string
}

/**
 * Request parameters for matchV2 operation in ValorantApi.
 * @export
 * @interface ValorantApiMatchV2Request
 */
export interface ValorantApiMatchV2Request {
    /**
     * Match UUID
     * @type {string}
     * @memberof ValorantApiMatchV2
     */
    readonly matchId: string
}

/**
 * Request parameters for matchV4 operation in ValorantApi.
 * @export
 * @interface ValorantApiMatchV4Request
 */
export interface ValorantApiMatchV4Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiMatchV4
     */
    readonly affinity: string

    /**
     * Match UUID
     * @type {string}
     * @memberof ValorantApiMatchV4
     */
    readonly matchId: string
}

/**
 * Request parameters for premierById operation in ValorantApi.
 * @export
 * @interface ValorantApiPremierByIdRequest
 */
export interface ValorantApiPremierByIdRequest {
    /**
     * Team UUID
     * @type {string}
     * @memberof ValorantApiPremierById
     */
    readonly id: string
}

/**
 * Request parameters for premierByIdHistory operation in ValorantApi.
 * @export
 * @interface ValorantApiPremierByIdHistoryRequest
 */
export interface ValorantApiPremierByIdHistoryRequest {
    /**
     * Team UUID
     * @type {string}
     * @memberof ValorantApiPremierByIdHistory
     */
    readonly id: string
}

/**
 * Request parameters for premierByName operation in ValorantApi.
 * @export
 * @interface ValorantApiPremierByNameRequest
 */
export interface ValorantApiPremierByNameRequest {
    /**
     * Team name
     * @type {string}
     * @memberof ValorantApiPremierByName
     */
    readonly name: string

    /**
     * Team tag
     * @type {string}
     * @memberof ValorantApiPremierByName
     */
    readonly tag: string
}

/**
 * Request parameters for premierByNameHistory operation in ValorantApi.
 * @export
 * @interface ValorantApiPremierByNameHistoryRequest
 */
export interface ValorantApiPremierByNameHistoryRequest {
    /**
     * Team name
     * @type {string}
     * @memberof ValorantApiPremierByNameHistory
     */
    readonly name: string

    /**
     * Team tag
     * @type {string}
     * @memberof ValorantApiPremierByNameHistory
     */
    readonly tag: string
}

/**
 * Request parameters for premierLeaderboard operation in ValorantApi.
 * @export
 * @interface ValorantApiPremierLeaderboardRequest
 */
export interface ValorantApiPremierLeaderboardRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiPremierLeaderboard
     */
    readonly affinity: string

    /**
     * Conference filter (optional)
     * @type {string}
     * @memberof ValorantApiPremierLeaderboard
     */
    readonly conference?: string

    /**
     * Division filter (optional)
     * @type {string}
     * @memberof ValorantApiPremierLeaderboard
     */
    readonly division?: string
}

/**
 * Request parameters for premierSearch operation in ValorantApi.
 * @export
 * @interface ValorantApiPremierSearchRequest
 */
export interface ValorantApiPremierSearchRequest {
    /**
     * Team name to search for (optional)
     * @type {string}
     * @memberof ValorantApiPremierSearch
     */
    readonly name?: string

    /**
     * Team tag to search for (optional)
     * @type {string}
     * @memberof ValorantApiPremierSearch
     */
    readonly tag?: string

    /**
     * Team UUID to search for (optional)
     * @type {string}
     * @memberof ValorantApiPremierSearch
     */
    readonly id?: string
}

/**
 * Request parameters for queueStatus operation in ValorantApi.
 * @export
 * @interface ValorantApiQueueStatusRequest
 */
export interface ValorantApiQueueStatusRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiQueueStatus
     */
    readonly affinity: string
}

/**
 * Request parameters for raw operation in ValorantApi.
 * @export
 * @interface ValorantApiRawRequest
 */
export interface ValorantApiRawRequest {
    /**
     * 
     * @type {RawV1Payload}
     * @memberof ValorantApiRaw
     */
    readonly rawV1Payload: RawV1Payload
}

/**
 * Request parameters for status operation in ValorantApi.
 * @export
 * @interface ValorantApiStatusRequest
 */
export interface ValorantApiStatusRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStatus
     */
    readonly affinity: string
}

/**
 * Request parameters for storeFeatured operation in ValorantApi.
 * @export
 * @interface ValorantApiStoreFeaturedRequest
 */
export interface ValorantApiStoreFeaturedRequest {
    /**
     * API version (v1, v2)
     * @type {string}
     * @memberof ValorantApiStoreFeatured
     */
    readonly version: string
}

/**
 * Request parameters for storeOffers operation in ValorantApi.
 * @export
 * @interface ValorantApiStoreOffersRequest
 */
export interface ValorantApiStoreOffersRequest {
    /**
     * API version (v1, v2)
     * @type {string}
     * @memberof ValorantApiStoreOffers
     */
    readonly version: string
}

/**
 * Request parameters for storedMatches operation in ValorantApi.
 * @export
 * @interface ValorantApiStoredMatchesRequest
 */
export interface ValorantApiStoredMatchesRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStoredMatches
     */
    readonly affinity: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiStoredMatches
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiStoredMatches
     */
    readonly tag: string

    /**
     * Game mode filter (optional)
     * @type {string}
     * @memberof ValorantApiStoredMatches
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     * @type {string}
     * @memberof ValorantApiStoredMatches
     */
    readonly map?: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiStoredMatches
     */
    readonly size?: number
}

/**
 * Request parameters for storedMatchesById operation in ValorantApi.
 * @export
 * @interface ValorantApiStoredMatchesByIdRequest
 */
export interface ValorantApiStoredMatchesByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStoredMatchesById
     */
    readonly affinity: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiStoredMatchesById
     */
    readonly puuid: string

    /**
     * Game mode filter (optional)
     * @type {string}
     * @memberof ValorantApiStoredMatchesById
     */
    readonly mode?: string

    /**
     * Map filter (optional)
     * @type {string}
     * @memberof ValorantApiStoredMatchesById
     */
    readonly map?: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiStoredMatchesById
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistory operation in ValorantApi.
 * @export
 * @interface ValorantApiStoredMmrHistoryRequest
 */
export interface ValorantApiStoredMmrHistoryRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStoredMmrHistory
     */
    readonly affinity: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiStoredMmrHistory
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiStoredMmrHistory
     */
    readonly tag: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiStoredMmrHistory
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistoryById operation in ValorantApi.
 * @export
 * @interface ValorantApiStoredMmrHistoryByIdRequest
 */
export interface ValorantApiStoredMmrHistoryByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryById
     */
    readonly affinity: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryById
     */
    readonly puuid: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiStoredMmrHistoryById
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistoryV2 operation in ValorantApi.
 * @export
 * @interface ValorantApiStoredMmrHistoryV2Request
 */
export interface ValorantApiStoredMmrHistoryV2Request {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2
     */
    readonly platform: string

    /**
     * Riot ID name
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2
     */
    readonly name: string

    /**
     * Riot ID tag
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2
     */
    readonly tag: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiStoredMmrHistoryV2
     */
    readonly size?: number
}

/**
 * Request parameters for storedMmrHistoryV2ById operation in ValorantApi.
 * @export
 * @interface ValorantApiStoredMmrHistoryV2ByIdRequest
 */
export interface ValorantApiStoredMmrHistoryV2ByIdRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2ById
     */
    readonly affinity: string

    /**
     * Platform (pc, console)
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2ById
     */
    readonly platform: string

    /**
     * Player UUID
     * @type {string}
     * @memberof ValorantApiStoredMmrHistoryV2ById
     */
    readonly puuid: string

    /**
     * Number of results (optional)
     * @type {number}
     * @memberof ValorantApiStoredMmrHistoryV2ById
     */
    readonly size?: number
}

/**
 * Request parameters for version operation in ValorantApi.
 * @export
 * @interface ValorantApiVersionRequest
 */
export interface ValorantApiVersionRequest {
    /**
     * Region/affinity (e.g., na, eu, ap, kr)
     * @type {string}
     * @memberof ValorantApiVersion
     */
    readonly affinity: string
}

/**
 * Request parameters for website operation in ValorantApi.
 * @export
 * @interface ValorantApiWebsiteRequest
 */
export interface ValorantApiWebsiteRequest {
    /**
     * Country code (e.g., en-us, de-de)
     * @type {string}
     * @memberof ValorantApiWebsite
     */
    readonly countryCode: string

    /**
     * Category filter (optional)
     * @type {string}
     * @memberof ValorantApiWebsite
     */
    readonly category?: string
}

/**
 * Request parameters for websiteById operation in ValorantApi.
 * @export
 * @interface ValorantApiWebsiteByIdRequest
 */
export interface ValorantApiWebsiteByIdRequest {
    /**
     * Database ID of the website entry
     * @type {string}
     * @memberof ValorantApiWebsiteById
     */
    readonly dbId: string

    /**
     * Country code (e.g., en-us, de-de)
     * @type {string}
     * @memberof ValorantApiWebsiteById
     */
    readonly countryCode: string
}

/**
 * ValorantApi - object-oriented interface
 * @export
 * @class ValorantApi
 * @extends {BaseAPI}
 */
export class ValorantApi extends BaseAPI {
    /**
     * 
     * @param {ValorantApiCrosshairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public crosshair(requestParameters: ValorantApiCrosshairRequest = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).crosshair(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiEsportsSchedulesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public esportsSchedulesV1(requestParameters: ValorantApiEsportsSchedulesV1Request = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).esportsSchedulesV1(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountByIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getAccountByIdV1(requestParameters: ValorantApiGetAccountByIdV1Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountByIdV1(requestParameters.puuid, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountByIdV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getAccountByIdV2(requestParameters: ValorantApiGetAccountByIdV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountByIdV2(requestParameters.puuid, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getAccountV1(requestParameters: ValorantApiGetAccountV1Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountV1(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetAccountV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getAccountV2(requestParameters: ValorantApiGetAccountV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getAccountV2(requestParameters.name, requestParameters.tag, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetContentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getContentV1(requestParameters: ValorantApiGetContentV1Request = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getContentV1(requestParameters.locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV3ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMatchesV3ById(requestParameters: ValorantApiGetMatchesV3ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV3ById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV3ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMatchesV3ByName(requestParameters: ValorantApiGetMatchesV3ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV3ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV4ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMatchesV4ById(requestParameters: ValorantApiGetMatchesV4ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV4ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMatchesV4ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMatchesV4ByName(requestParameters: ValorantApiGetMatchesV4ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMatchesV4ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, requestParameters.start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrHistoryById(requestParameters: ValorantApiGetMmrHistoryByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrHistoryByName(requestParameters: ValorantApiGetMmrHistoryByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryV2ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrHistoryV2ById(requestParameters: ValorantApiGetMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrHistoryV2ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrHistoryV2ByName(requestParameters: ValorantApiGetMmrHistoryV2ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrHistoryV2ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV1ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrV1ById(requestParameters: ValorantApiGetMmrV1ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV1ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV1ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrV1ByName(requestParameters: ValorantApiGetMmrV1ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV1ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV2ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrV2ById(requestParameters: ValorantApiGetMmrV2ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV2ById(requestParameters.affinity, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV2ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrV2ByName(requestParameters: ValorantApiGetMmrV2ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV2ByName(requestParameters.affinity, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV3ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrV3ById(requestParameters: ValorantApiGetMmrV3ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV3ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiGetMmrV3ByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public getMmrV3ByName(requestParameters: ValorantApiGetMmrV3ByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).getMmrV3ByName(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiLeaderboardV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public leaderboardV1(requestParameters: ValorantApiLeaderboardV1Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).leaderboardV1(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiLeaderboardV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public leaderboardV2(requestParameters: ValorantApiLeaderboardV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).leaderboardV2(requestParameters.affinity, requestParameters.season, requestParameters.name, requestParameters.tag, requestParameters.puuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiLeaderboardV3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public leaderboardV3(requestParameters: ValorantApiLeaderboardV3Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).leaderboardV3(requestParameters.affinity, requestParameters.platform, requestParameters.season, requestParameters.size, requestParameters.page, requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiMatchV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public matchV2(requestParameters: ValorantApiMatchV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).matchV2(requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiMatchV4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public matchV4(requestParameters: ValorantApiMatchV4Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).matchV4(requestParameters.affinity, requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public premierById(requestParameters: ValorantApiPremierByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByIdHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public premierByIdHistory(requestParameters: ValorantApiPremierByIdHistoryRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierByIdHistory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public premierByName(requestParameters: ValorantApiPremierByNameRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierByName(requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierByNameHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public premierByNameHistory(requestParameters: ValorantApiPremierByNameHistoryRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierByNameHistory(requestParameters.name, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierLeaderboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public premierLeaderboard(requestParameters: ValorantApiPremierLeaderboardRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierLeaderboard(requestParameters.affinity, requestParameters.conference, requestParameters.division, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiPremierSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public premierSearch(requestParameters: ValorantApiPremierSearchRequest = {}, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).premierSearch(requestParameters.name, requestParameters.tag, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiQueueStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public queueStatus(requestParameters: ValorantApiQueueStatusRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).queueStatus(requestParameters.affinity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiRawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public raw(requestParameters: ValorantApiRawRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).raw(requestParameters.rawV1Payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public status(requestParameters: ValorantApiStatusRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).status(requestParameters.affinity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoreFeaturedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storeFeatured(requestParameters: ValorantApiStoreFeaturedRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storeFeatured(requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoreOffersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storeOffers(requestParameters: ValorantApiStoreOffersRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storeOffers(requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storedMatches(requestParameters: ValorantApiStoredMatchesRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMatches(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMatchesByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storedMatchesById(requestParameters: ValorantApiStoredMatchesByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMatchesById(requestParameters.affinity, requestParameters.puuid, requestParameters.mode, requestParameters.map, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storedMmrHistory(requestParameters: ValorantApiStoredMmrHistoryRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistory(requestParameters.affinity, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storedMmrHistoryById(requestParameters: ValorantApiStoredMmrHistoryByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistoryById(requestParameters.affinity, requestParameters.puuid, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storedMmrHistoryV2(requestParameters: ValorantApiStoredMmrHistoryV2Request, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistoryV2(requestParameters.affinity, requestParameters.platform, requestParameters.name, requestParameters.tag, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiStoredMmrHistoryV2ByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public storedMmrHistoryV2ById(requestParameters: ValorantApiStoredMmrHistoryV2ByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).storedMmrHistoryV2ById(requestParameters.affinity, requestParameters.platform, requestParameters.puuid, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public version(requestParameters: ValorantApiVersionRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).version(requestParameters.affinity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiWebsiteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public website(requestParameters: ValorantApiWebsiteRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).website(requestParameters.countryCode, requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValorantApiWebsiteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValorantApi
     */
    public websiteById(requestParameters: ValorantApiWebsiteByIdRequest, options?: RawAxiosRequestConfig) {
        return ValorantApiFp(this.configuration).websiteById(requestParameters.dbId, requestParameters.countryCode, options).then((request) => request(this.axios, this.basePath));
    }
}



